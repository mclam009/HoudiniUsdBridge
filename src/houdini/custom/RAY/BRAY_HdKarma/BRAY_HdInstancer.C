/*
 * Copyright 2019 Side Effects Software Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Produced by:
 *      Side Effects Software Inc.
 *      123 Front Street West, Suite 1401
 *      Toronto, Ontario
 *      Canada   M5J 2M2
 *      416-504-9876
 *
 */

#include "BRAY_HdInstancer.h"

#include <pxr/imaging/hd/sceneDelegate.h>

#include <HUSD/XUSD_Format.h>
#include <HUSD/XUSD_Tokens.h>
#include <HUSD/XUSD_HydraUtils.h>
#include <UT/UT_Debug.h>
#include <UT/UT_Set.h>
#include <UT/UT_ErrorLog.h>
#include <UT/UT_SmallArray.h>
#include <UT/UT_VarEncode.h>
#include <UT/UT_JSONWriter.h>
#include "BRAY_HdUtil.h"
#include "BRAY_HdParam.h"

PXR_NAMESPACE_OPEN_SCOPE

#if 0
// Define local tokens for the names of the primvars the instancer
// consumes.
// XXX: These should be hydra tokens...
TF_DEFINE_PRIVATE_TOKENS(
    _tokens,
    (instanceTransform)
    (rotate)
    (scale)
    (translate)
);
#endif

namespace
{
    static UT_Set<TfToken> &
    transformTokens()
    {
	static UT_Set<TfToken>	theTokens({
		HusdHdPrimvarTokens()->translate,
		HusdHdPrimvarTokens()->rotate,
		HusdHdPrimvarTokens()->scale,
		HusdHdPrimvarTokens()->instanceTransform
	});
	return theTokens;
    }

    // Split an attribute list into shader attributes and properties.  Property
    // names will be encoded and prefixed with "karma:object:"
    void
    splitAttributes(const GT_AttributeListHandle &source,
            GT_AttributeListHandle &attribs,
            GT_AttributeListHandle &properties)
    {
        if (!source)
            return;
        static constexpr UT_StringLit   thePrefix("karma:object:");
        UT_StringArray                  snames;
        GT_AttributeMapHandle           pmap;
        UT_SmallArray<int>              pidx;
        for (int i = 0, n = source->entries(); i < n; ++i)
        {
            const UT_StringHolder       &sname = source->getName(i);
            UT_StringHolder              dname = UT_VarEncode::decodeVar(sname);
            if (dname.startsWith(thePrefix))
            {
                snames.append(sname);
                if (!pmap)
                    pmap.reset(new GT_AttributeMap());

                // Strip off prefix
                UT_StringHolder stripped(dname.c_str() + thePrefix.length());
                pidx.append(pmap->add(stripped, false));
                UT_ASSERT(pidx.last() >= 0);
            }
        }
        if (!snames.size())
        {
            // Common case with no attributes
            attribs = source;
            return;
        }
        if (snames.size() != source->entries())
            attribs = source->removeAttributes(snames);

        // Currently, properties cannot be motion blurred
        properties.reset(new GT_AttributeList(pmap, 1));
        for (int i = 0, n = snames.size(); i < n; ++i)
        {
            properties->set(pidx[i], source->get(snames[i]));
        }
    }

    void
    velocityBlur(const SdfPath &id,
            const VtIntArray &instanceindices,
            int nsegs, const VtArray<GfVec3f> &velocities,
            const VtArray<GfVec3f> *accel,
            VtMatrix4dArray *xformList, const float *shutter_times)
    {
        size_t  nitems = velocities.size();
        for (int seg = 0; seg < nsegs; ++seg)
        {
            if (shutter_times[seg] == 0)
                continue;

            float       tm = shutter_times[seg];
            float       a = .5*tm*tm;
            for (size_t i = 0, m = instanceindices.size(); i < m; ++i)
            {
                size_t idx = instanceindices[i];
                if (idx >= nitems) // invalid idx?
                    continue;

                const GfVec3f   &velf = velocities[idx];
                GfMatrix4d       xlate(1.0);
                GfVec3d          vel(velf[0]*tm, velf[1]*tm, velf[2]*tm);
                if (accel)
                {
                    const GfVec3f &acc = (*accel)[idx];
                    vel += GfVec3d(acc[0]*a, acc[1]*a, acc[2]*a);
                }
                xlate.SetTranslate(vel);
                xformList[seg][i] = xformList[seg][i] * xlate;
            }
        }
    }
}

#if 0
static void
dumpDesc(HdSceneDelegate *sd, HdInterpolation style, const SdfPath &id)
{
    const auto	&descs = sd->GetPrimvarDescriptors(id, style);
    if (!descs.size())
	return;
    UTdebugFormat("-- {} {} --", id, TfEnum::GetName(style));
    for (auto &d : descs)
	UTdebugFormat("  {}", d.name);
}

static void
dumpAllDesc(HdSceneDelegate *sd, const SdfPath &id)
{
    UTdebugFormat("-- {} --", id);
    for (auto &&style : {
	        HdInterpolationConstant,
		HdInterpolationUniform,
		HdInterpolationVarying,
		HdInterpolationVertex,
		HdInterpolationFaceVarying,
		HdInterpolationInstance,
	    })
	dumpDesc(sd, style, id);
}
#endif

BRAY_HdInstancer::BRAY_HdInstancer(HdSceneDelegate* delegate,
                                     SdfPath const& id)
    : XUSD_HydraInstancer(delegate, id)
    , myNewObject(false)
    , mySegments(2)
    , myMotionBlur(MotionBlurStyle::ACCEL)
{
}

BRAY_HdInstancer::~BRAY_HdInstancer()
{
}

void
BRAY_HdInstancer::applyNesting(BRAY_HdParam &rparm,
	BRAY::ScenePtr &scene)
{
    if (!myInstanceMap.size())
	return;

    // Make sure to build the scene graph if required
    BRAY::ObjectPtr	proto;

    if (myInstanceMap.size() > 1)
    {
	// In this case, we have multiple objects being instanced.  For this we
	// want to aggregate the edits into a scene graph.
	if (!mySceneGraph)
	{
	    myNewObject = true;
	    mySceneGraph = BRAY::ObjectPtr::createScene();
	    for (auto &&inst : myInstanceMap)
		mySceneGraph.addInstanceToScene(inst.second);
	}
	else
	{
	    myNewObject = false;
	    scene.updateObject(mySceneGraph, BRAY_EVENT_CONTENTS);
	}
	proto = mySceneGraph;	// This is the object we want to process
    }
    else
    {
	for (auto &&inst : myInstanceMap)
	{
	    UT_ASSERT(!proto);
	    proto = inst.second;
	    break;
	}
    }

    if (GetParentId().IsEmpty())
    {
	if (myNewObject)
	{
	    myNewObject = false;
	    scene.updateObject(proto, BRAY_EVENT_NEW);
	}
    }
    else
    {
	HdInstancer	*parentInstancer =
	    GetDelegate()->GetRenderIndex().GetInstancer(GetParentId());
	UT_ASSERT(parentInstancer);
	UT_SmallArray<GfMatrix4d>	px;
	px.emplace_back(1.0);

	UTverify_cast<BRAY_HdInstancer *>(parentInstancer)->
	    NestedInstances(rparm, scene, GetId(), proto, px,
                    proto.objectProperties(scene));

    }
}

GT_AttributeListHandle
BRAY_HdInstancer::extractListForPrototype(const SdfPath &protoId,
        const GT_AttributeListHandle &list) const
{
    // If there are no attributes, just return an empty array
    if (!list || !list->entries())
	return GT_AttributeListHandle();

    VtIntArray	indices = GetDelegate()->GetInstanceIndices(GetId(), protoId);
    auto alist_size = list->get(0)->entries();
    if (indices.size() == alist_size)
	return list;
    GT_DataArrayHandle	gt_indices = XUSD_HydraUtils::createGTArray(indices);
    return list->createIndirect(gt_indices);
}

UT_Array<exint>
BRAY_HdInstancer::instanceIdsForPrototype(const SdfPath &protoId)
{
    VtIntArray	indices = GetDelegate()->GetInstanceIndices(GetId(), protoId);
    UT_Array<exint> result(indices.size());
    bool contiguous = true;
    for (exint i = 0, n = indices.size(); i < n; ++i)
    {
	result.append(indices[i]);
	if (indices[i] != i)
	    contiguous = false;
    }

    if (contiguous)
	return UT_Array<exint>();

    return result;
}

static inline int
getInt(const VtValue &val, int def)
{
    if (val.IsEmpty())
        return def;
    if (val.IsHolding<int32>())
        return val.UncheckedGet<int32>();
    if (val.IsHolding<int64>())
        return val.UncheckedGet<int64>();
    if (val.IsHolding<uint8>())
        return val.UncheckedGet<uint8>();
    UT_ASSERT(0 && "Unexpected integer value");
    return def;
}

static inline bool
getBool(const VtValue &val, bool def)
{
    if (val.IsEmpty())
        return def;
    if (val.IsHolding<bool>())
        return val.UncheckedGet<bool>();
    return 0 != getInt(val, def ? 1 : 0);
}

void
BRAY_HdInstancer::loadBlur(const BRAY_HdParam &rparm,
        HdSceneDelegate *sd,
        const SdfPath &id,
        BRAY::OptionSet &props)
{
    if (rparm.instantShutter())
    {
        myMotionBlur = MotionBlurStyle::NONE;
        mySegments = 1;
        return;
    }

    bool        enable;
    if (!props.import(BRAY_OBJ_MOTION_BLUR, &enable, 1))
    {
        UT_ASSERT(0);
        enable = true;
    }
    if (!enable)
    {
        myMotionBlur = MotionBlurStyle::NONE;
        mySegments = 1;
        return;
    }

    int         vblur, isamp;
    if (!props.import(BRAY_OBJ_INSTANCE_VELBLUR, &vblur, 1))
        vblur = 0;
    if (!props.import(BRAY_OBJ_INSTANCE_SAMPLES, &isamp, 1))
        isamp = 2;
    if (vblur < 0 || vblur > 2)
    {
        UT_ErrorLog::error("Invalid instance velocity blur {} ({})",
                vblur, id);
        vblur = 0;
    }
    if (isamp < 1)
    {
        UT_ErrorLog::error("Invalid instance blur samples {} ({})",
                isamp, id);
        isamp = 1;
    }
    mySegments = SYSmax(1, isamp);
    if (mySegments < 2)
    {
        myMotionBlur = MotionBlurStyle::NONE;
        return;
    }
    switch (vblur)
    {
        case 0:
            myMotionBlur = MotionBlurStyle::DEFORM;
            break;
        case 1:
            myMotionBlur = MotionBlurStyle::VELOCITY;
            mySegments = 2;     // Clamp to 2 segmetns
            break;
        case 2:
            myMotionBlur = MotionBlurStyle::ACCEL;
            break;
        default:
            UT_ASSERT(0);
    }
}

void
BRAY_HdInstancer::syncPrimvars(HdSceneDelegate* delegate,
        HdRenderParam* renderParam,
        HdDirtyBits* dirtyBits,
        int nsegs)
{
    // When this is called from HUSD, we always pass in a 1.  However, the
    // method allows us to override the segments based on the instance's motion
    // blur.
    UT_ASSERT(nsegs == 1);
    BRAY_HdParam        &rparm = *UTverify_cast<BRAY_HdParam *>(renderParam);
    BRAY::ScenePtr      &scene = rparm.getSceneForEdit();

    const SdfPath       &id = GetId();

    if (HdChangeTracker::IsAnyPrimvarDirty(*dirtyBits, id) ||
        HdChangeTracker::IsTransformDirty(*dirtyBits, id))
    {
        // Set up motion blur properties for the instance.  In this case, we
        // re-map the instance blur settings to the object blur settings for
        // BRAY_HdUtil.
        BRAY::OptionSet propstmp = scene.objectProperties().duplicate();
        BRAY_HdUtil::updateObjectProperties(propstmp, *delegate, id);

        // Load motion blur settings
        loadBlur(rparm, delegate, id, propstmp);

        // XXX NOTE that in USD 21.02, UsdImagingPointInstancerAdapter::Get()
        // is broken and the following will not return valid values.
        // SamplePrivmar() will work only if the camera shutter open value is
        // positive (otherwise it will return previous frame's), so stick with
        // Get() for now and hope that later version of USD addresses it.
        myVelocities = GetDelegate()->Get(id, HdTokens->velocities);
        myAccelerations = GetDelegate()->Get(id, HdTokens->accelerations);

        if (!myVelocities.IsHolding<VtArray<GfVec3f>>())
        {
            if (myMotionBlur == MotionBlurStyle::VELOCITY
                    || myMotionBlur == MotionBlurStyle::ACCEL)
            {
                myMotionBlur = MotionBlurStyle::NONE;
                mySegments = 1;
            }
        }
        else if (!myAccelerations.IsHolding<VtArray<GfVec3f>>())
        {
            if (myMotionBlur == MotionBlurStyle::ACCEL)
            {
                myMotionBlur = MotionBlurStyle::VELOCITY;
                mySegments = 2;
            }
        }

        propstmp.set(BRAY_OBJ_MOTION_BLUR, myMotionBlur != MotionBlurStyle::NONE);
        propstmp.set(BRAY_OBJ_GEO_SAMPLES, mySegments);
        switch (myMotionBlur)
        {
            case MotionBlurStyle::NONE:
                propstmp.set(BRAY_OBJ_GEO_VELBLUR, 0);
                UT_ASSERT(mySegments == 1);
                break;
            case MotionBlurStyle::DEFORM:
                propstmp.set(BRAY_OBJ_GEO_VELBLUR, 0);
                UT_ASSERT(mySegments >= 2);
                break;
            case MotionBlurStyle::VELOCITY:
                UT_ASSERT(mySegments == 2);
                propstmp.set(BRAY_OBJ_GEO_VELBLUR, 1);
                break;
            case MotionBlurStyle::ACCEL:
                propstmp.set(BRAY_OBJ_GEO_VELBLUR, 2);
                UT_ASSERT(mySegments >= 2);
                break;
        }

        // Make an attribute list, but exclude all the tokens for
        // transforms We need to capture attributes before syncPrimvars()
        // clears the dirty bits when it caches the transform data.
        //
        // NOTE: There's a possible indeterminant order here.  The
        // prototypes can be processed in arbitrary order, but the
        // prototype's motion blur settings are used to determine the
        // motion segments for attributes on the instance attribs.  So, if
        // prototypes have different motion blur settings, the behaviour of
        // the instance evaluation might be different.
        if (HdChangeTracker::IsAnyPrimvarDirty(*dirtyBits, id))
        {
            myAttributes = BRAY_HdUtil::makeAttributes(GetDelegate(),
                            rparm,
                            GetId(),
                            HdInstancerTokens->instancer,
                            -1,
                            propstmp,
                            HdInterpolationInstance,
                            &transformTokens(),
                            false);
            // Don't clear the dirty bits since we need to discover this
            // when computing transforms.
        }
    }

    // When we compute our transforms, we only use multiple segments for
    // deformation blur.  All other styles need to have a single evaluation
    // (for example, with velocity blur, the point count could be changing).
    XUSD_HydraInstancer::syncPrimvars(delegate, renderParam, dirtyBits,
            myMotionBlur == MotionBlurStyle::DEFORM ? mySegments : 1);
}

static void
dump(const BRAY::OptionSet &prop, const char *msg)
{
    UTdebugFormat("Props: {}", msg);
    UT_AutoJSONWriter   w(std::cerr, false);
    prop.dump(*w);
}

void
BRAY_HdInstancer::NestedInstances(BRAY_HdParam &rparm,
	BRAY::ScenePtr &scene,
	SdfPath const &prototypeId,
	const BRAY::ObjectPtr &protoObj,
	const UT_Array<GfMatrix4d> &protoXform,
        const BRAY::OptionSet &protoProps)
{
    HD_TRACE_FUNCTION();
    HF_MALLOC_TAG_FUNCTION();

    const SdfPath                      &id = GetId();
    UT_Array<BRAY::SpacePtr>            xforms;

    UT_StackBuffer<VtMatrix4dArray>     xformList(mySegments);
    UT_StackBuffer<float>               shutter_times(mySegments);

    rparm.fillShutterTimes(shutter_times, mySegments);
    for (int i = 0; i < mySegments; ++i)
    {
        if (myMotionBlur != MotionBlurStyle::DEFORM
                && i > 0
                && protoXform.size() == 1)
        {
            // When we have velocity/acceleration blur, we just pull out the
            // first transform
            xformList[i] = xformList[0];     // Copy xforms from prev segment
        }
        else
        {
            int	pidx = SYSmin(i, int(protoXform.size()-1));
            xformList[i] = computeTransforms(prototypeId, false,
                                &protoXform[pidx], shutter_times[i],
                                -1 /* don't set viewport "instance id" */);
        }
    }
    if (myMotionBlur == MotionBlurStyle::VELOCITY
            || myMotionBlur == MotionBlurStyle::ACCEL)
    {
        UT_ASSERT(mySegments > 1 && myVelocities.IsHolding<VtArray<GfVec3f>>());
        UT_StackBuffer<float>    frameTimes(mySegments);
        VtArray<GfVec3f>         astore;
        const VtArray<GfVec3f>  *accelerations = nullptr;
        rparm.shutterToFrameTime(frameTimes.array(),
                shutter_times.array(), mySegments);
        if (myMotionBlur == MotionBlurStyle::ACCEL)
        {
            UT_ASSERT(myAccelerations.IsHolding<VtArray<GfVec3f>>());
            astore = myAccelerations.UncheckedGet<VtArray<GfVec3f>>();
            accelerations = &astore;
        }

        VtIntArray instanceindices =
            GetDelegate()->GetInstanceIndices(id, prototypeId);
        velocityBlur(id, instanceindices, mySegments,
                    myVelocities.UncheckedGet<VtArray<GfVec3f>>(),
                    accelerations,
                    xformList.array(),
                    frameTimes.array());
    }
    BRAY_HdUtil::makeSpaceList(xforms, xformList.array(), mySegments);

    bool		 new_instance = false;
    BRAY::ObjectPtr	&inst = findOrCreate(prototypeId);
    if (!inst)
    {
	new_instance = true;
	myNewObject = true;	// There's a new object in me

        // use prototype ID for leaf instances (which will have the instance
        // ID baked in anyway).  This allows for unique naming, and matches
        // the non-nested instance naming convention as well.
        UT_StringHolder name =  protoObj.isLeaf()  ?
                                BRAY_HdUtil::toStr(prototypeId) :
                                BRAY_HdUtil::toStr(GetId());

	inst = BRAY::ObjectPtr::createInstance(protoObj, name);
    }

    // Update information
    inst.setInstanceTransforms(xforms);
    GT_AttributeListHandle      attribs, properties;
    splitAttributes(attributesForPrototype(prototypeId), attribs, properties);
    inst.setInstanceAttributes(scene, attribs);

    // Update per-xform light linking
    GT_DataArrayHandle categories;
    {
        UT_Lock::Scope lock(myLock);
        UT_Map<SdfPath, GT_DataArrayHandle>::iterator it =
            myCategories.find(prototypeId);
        if(it != myCategories.end())
            categories = it->second;
    }

    if (categories)
    {
        static constexpr UT_StringLit theLightCategoryAttr("lightcategories");
        UT_ASSERT(categories->entries() == xforms.size());
        if (properties)
        {
            properties = properties->addAttribute(
                theLightCategoryAttr.asHolder(), categories, false);
        }
        else
        {
            properties = GT_AttributeList::createAttributeList(
                theLightCategoryAttr.asHolder(), categories);
        }
    }

    inst.setInstanceProperties(scene, properties);
    inst.setInstanceIds(instanceIdsForPrototype(prototypeId));
    inst.validateInstance();

    if (!new_instance)
	scene.updateObject(inst, BRAY_EVENT_XFORM);

    // Make sure to process myself after all my children have been processed.
    rparm.queueInstancer(GetDelegate(), this);
}

void
BRAY_HdInstancer::eraseFromScenegraph(BRAY::ScenePtr &scene)
{
    // post delete for all instances
    for (auto &&inst : myInstanceMap)
    {
	UT_ASSERT(inst.second);
	scene.updateObject(inst.second, BRAY_EVENT_DEL);
    }

    // also post delete for the scenegraph (if we have one)
    if (mySceneGraph)
	scene.updateObject(mySceneGraph, BRAY_EVENT_DEL);
}

BRAY::ObjectPtr &
BRAY_HdInstancer::findOrCreate(const SdfPath &prototypeId)
{
    UT_Lock::Scope	lock(myLock);
    // If this is a new entry in the map, it will be initialized by the caller
    return myInstanceMap[prototypeId];
}

int
BRAY_HdInstancer::getNestLevel() const
{
    int nestlevel = 0;
    const HdInstancer *instancer = this;
    while (!instancer->GetParentId().IsEmpty())
    {
        nestlevel++;
        instancer = GetDelegate()->GetRenderIndex().GetInstancer(
            instancer->GetParentId());
    }
    return nestlevel;
}

PXR_NAMESPACE_CLOSE_SCOPE

