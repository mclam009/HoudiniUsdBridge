/*
 * Copyright 2019 Side Effects Software Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Produced by:
 *	Side Effects Software Inc
 *	123 Front Street West, Suite 1401
 *	Toronto, Ontario
 *	Canada   M5J 2M2
 *	416-504-9876
 *
 * NAME:	XUSD_HydraGeoPrim.C (HUSD Library, C++)
 *
 * COMMENTS:	Container for a hydra geometry prim (HdRprim)
 */

#include "XUSD_HydraGeoPrim.h"
#include "XUSD_HydraExtComputation.h"
#include "XUSD_HydraInstancer.h"
#include "XUSD_HydraField.h"
#include "XUSD_HydraUtils.h"
#include "XUSD_ViewerDelegate.h"
#include "XUSD_Format.h"
#include "XUSD_Tokens.h"
#include "HUSD_HydraGeoPrim.h"
#include "HUSD_HydraMaterial.h"
#include "HUSD_Path.h"
#include "HUSD_Scene.h"

#include <pxr/imaging/hd/tokens.h>
#include <pxr/imaging/hd/sceneDelegate.h>
#include <pxr/imaging/hd/enums.h>
#include <pxr/imaging/hd/extComputationUtils.h>
#include <pxr/usdImaging/usdImaging/debugCodes.h>
#include <gusd/UT_Gf.h>

#include <GT/GT_AttributeList.h>
#include <GT/GT_CatPolygonMesh.h>
#include <GT/GT_DAClampedArray.h>
#include <GT/GT_DAConstant.h>
#include <GT/GT_DAConstantValue.h>
#include <GT/GT_DAIndexedString.h>
#include <GT/GT_DAIndirect.h>
#include <GT/GT_DANumeric.h>
#include <GT/GT_DASubArray.h>
#include <GT/GT_MikkT.h>
#include <GT/GT_Names.h>
#include <GT/GT_Primitive.h>
#include <GT/GT_PrimPointMesh.h>
#include <GT/GT_PrimPolygonMesh.h>
#include <GT/GT_PrimSubdivisionMesh.h>
#include <GT/GT_PrimCurveMesh.h>
#include <GT/GT_PrimVDB.h>
#include <GT/GT_PrimInstance.h>
#include <GT/GT_Util.h>
#include <UT/UT_Lock.h>

// Debug stuff
#include <UT/UT_Debug.h>
#include "HUSD_GetAttributes.h"

#define CONSOLIDATE_SMALL_MESHES
// Vertex count below which a mesh is considered "small" and will be
// consolidated with other compatible small meshes
#define SMALL_MESH_MAX_VERTS            4000

// Max total vertices when unrolling instancing to a mesh
#define SMALL_MESH_INSTANCE_LIMIT      40000

// Unrolling cannot increase memory use of the mesh by more than this factor
#define SMALL_MESH_UNROLL_MEM_LIMIT       20   

// Perform the mesh deformations for skinning operations on the GPU
//#define GPU_MESH_DEFORMATION

using namespace UT::Literal;

PXR_NAMESPACE_OPEN_SCOPE

static int64 XUSDgetIntValue(const VtValue &value, int64 default_value)
{
    if(value.IsHolding<int32>())
        return value.Get<int32>();
    else if(value.IsHolding<int64>())
        return value.Get<int64>();
    else if(value.IsHolding<float>())
        return value.Get<float>();
    return default_value;
}    


XUSD_HydraGeoPrim::XUSD_HydraGeoPrim(TfToken const& type_id,
				     SdfPath const& prim_id,
				     HUSD_Scene &scene)
    : HUSD_HydraGeoPrim(scene, prim_id),
      myHydraPrim(nullptr),
      myPrimBase(nullptr),
      myTypeID(type_id)
{
    if(type_id == HdPrimTypeTokens->mesh)
    {
	auto prim = 
	    new XUSD_HydraGeoMesh(type_id, prim_id,
				  myGTPrim, myInstance, myDirtyMask, *this);
	myHydraPrim = prim;
	myPrimBase = prim;
    }
    else if(type_id == HdPrimTypeTokens->basisCurves)
    {
	auto prim = 
	    new XUSD_HydraGeoCurves(type_id, prim_id,
				    myGTPrim, myInstance, myDirtyMask, *this);
	myHydraPrim = prim;
	myPrimBase = prim;
    }
    else if(type_id == HusdHdPrimTypeTokens->metaCurves)
    {
        auto prim =
            new XUSD_HydraGeoCurves(type_id, prim_id,
                myGTPrim, myInstance, myDirtyMask, *this);
        myHydraPrim = prim;
        myPrimBase = prim;
    }
    else if(type_id == HdPrimTypeTokens->volume)
    {
	auto prim = 
	    new XUSD_HydraGeoVolume(type_id, prim_id,
				    myGTPrim, myInstance, myDirtyMask, *this);
	myHydraPrim = prim;
	myPrimBase = prim;
    }
    else if(type_id == HdPrimTypeTokens->points)
    {
	auto prim = 
	    new XUSD_HydraGeoPoints(type_id, prim_id,
				    myGTPrim, myInstance, myDirtyMask, *this);
	myHydraPrim = prim;
	myPrimBase = prim;
    }
    else if(type_id == HusdHdPrimTypeTokens->boundingBox)
    {
	auto prim = 
	    new XUSD_HydraGeoBounds(type_id, prim_id,
				    myGTPrim, myInstance, myDirtyMask, *this);
	myHydraPrim = prim;
	myPrimBase = prim;
    }
}

XUSD_HydraGeoPrim::~XUSD_HydraGeoPrim()
{
    delete myHydraPrim;
}

HUSD_Path
XUSD_HydraGeoPrim::getTopLevelPath(HdSceneDelegate *sdel,
                                   SdfPath const& prim_id,
                                   SdfPath const& instancer_id)
{
    if(instancer_id.IsEmpty())
        return prim_id;
    
    auto instancer= sdel->GetRenderIndex().GetInstancer(instancer_id);
    while(instancer)
    {
        if(instancer->GetParentId().IsEmpty())
            return instancer->GetId();
        
        instancer=sdel->GetRenderIndex().GetInstancer(instancer->GetParentId());
    }

    return prim_id;
}

const UT_Array<HUSD_Path> &
XUSD_HydraGeoPrim::materials() const
{
    return myPrimBase->materials();
}

// ------------------------------------------------------------------------

XUSD_HydraGeoBase::XUSD_HydraGeoBase(GT_PrimitiveHandle &prim,
                                     GT_PrimitiveHandle &instance,
                                     int &dirty,
                                     XUSD_HydraGeoPrim &hprim)
    : myGTPrim(prim),
      myInstance(instance),
      myDirtyMask(dirty),
      myPrevDirtyBits(0),
      myInstanceId(0),
      myPrimTransform(1.0),
      myHydraPrim(hprim),
      myMaterialID(-1),
      myHasSelection(false)
{
    myGTPrimTransform = new GT_Transform();
    myGTPrimTransform->alloc(1);
}

void
XUSD_HydraGeoBase::resetPrim()
{
    myGTPrim.reset();

    myAttribMap.clear();
    myInstanceTransforms.reset();
}

void
XUSD_HydraGeoBase::clearDirty(HdDirtyBits *dirty_bits,
                              DirtyClear clear)
{
    if(*dirty_bits)
	myHydraPrim.bumpVersion();

    if(clear == HOLD_DIRTY_BITS)
        myPrevDirtyBits = *dirty_bits;
    else
        myPrevDirtyBits = 0;

    *dirty_bits = (*dirty_bits & HdChangeTracker::Varying);
    myHydraPrim.setInitialized();
}

bool
XUSD_HydraGeoBase::isDeferred(const SdfPath &id,
                              HdSceneDelegate *sd,
                              HdRenderParam *rparm,
			      HdDirtyBits &bits) const
{
    auto srparm = static_cast<XUSD_ViewerRenderParam *>(rparm);

    if(srparm->scene().isDeferredUpdate())
    {
        // Always set the tag so t
        // hat we don't get purposes crossed when
        // switching back to HGL. 
        HUSD_HydraPrim::RenderTag tag =
            HUSD_HydraPrim::renderTag(sd->GetRenderTag(id));
        myHydraPrim.setRenderTag(tag);

	// Remember the dirty bits we are deferring. Combine the current
	// dirty bits with any existing dirty bits in case the prim is
	// changed in differetn ways by different edit operations. We need
	// to track the union of all changes.
	myHydraPrim.setDeferredBits(bits | myHydraPrim.deferredBits());
        
	// Clear the dirty bits, or else the HdChangeTracker will record the
	// fact that the current bits are dirty, so subsequent edits of the
	// same type will not be recorded as changes, and so the adapter will
	// not be called to update the value cache. We would be left fetching
	// an out of date value from the cache when we perform our updates.
	bits = (bits & HdChangeTracker::Varying);
	return true;
    }
    
    myHydraPrim.setDeferredBits(0);
    return false;
}
    

GEO_ViewportLOD
XUSD_HydraGeoBase::checkVisibility(HdSceneDelegate *scene,
				   const SdfPath   &id,
				   HdDirtyBits     *dirty_bits)
{
    if(*dirty_bits & HdChangeTracker::DirtyVisibility)
    {
	myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::LOD_CHANGE;
	*dirty_bits = *dirty_bits & ~HdChangeTracker::DirtyVisibility;
    }
    
    GEO_ViewportLOD lod = GEO_VIEWPORT_FULL;

    // check for visibility.
    bool vis = scene->GetVisible(id);
    if(!vis)
	lod = GEO_VIEWPORT_HIDDEN;
    
    if(myInstance && myInstance->getDetailAttributes())
    {
	auto loda = myInstance->getDetailAttributes()->
	    get(GT_Names::view_lod_mask);
	if(loda)
	{
	    auto *lodd = static_cast<GT_DAConstantValue<int> *>(loda.get());
	    lodd->set(1<<lod);
	}
    }
    return lod;
}

bool
XUSD_HydraGeoBase::addBBoxAttrib(HdSceneDelegate* sceneDelegate,
				 const SdfPath		&id,
				 GT_AttributeListHandle &detail,
				 const GT_Primitive	*gt_prim,
                                 const GfRange3d        *known_extents) const
{
    GfRange3d extents = known_extents
        ? *known_extents
        : sceneDelegate->GetExtent(id);
    UT_BoundingBox bbox(extents.GetMin()[0],
			extents.GetMin()[1],
			extents.GetMin()[2],
			extents.GetMax()[0],
			extents.GetMax()[1],
			extents.GetMax()[2]);
    if(bbox.isValid())
    {
	GT_Util::addBBoxAttrib(bbox, detail);
	return true;
    }
    else
    {
	bbox.makeInvalid();
	gt_prim->enlargeBounds(&bbox, 1);
	if(bbox.isValid())
	{
	    GT_Util::addBBoxAttrib(bbox, detail);
	    return true;
	}
    }

    return false;
}

bool
XUSD_HydraGeoBase::processInstancerOverrides(
    HdSceneDelegate         *sd,
    HdRenderParam           *rparm,
    const SdfPath           &inst_id,
    const SdfPath           &proto_id,
    HdDirtyBits             *dirty_bits,
    int                      inst_level,
    int                     &ninst)
{
    auto xinst = UTverify_cast<XUSD_HydraInstancer *>(
        sd->GetRenderIndex().GetInstancer(inst_id));
    if (!xinst)
        return false;

    auto descs = sd->GetPrimvarDescriptors(inst_id, HdInterpolationInstance);
    auto cdescs = sd->GetPrimvarDescriptors(inst_id, HdInterpolationConstant);
    descs.insert(descs.end(), cdescs.begin(), cdescs.end());
    
    VtIntArray instanceIndices = sd->GetInstanceIndices(inst_id, proto_id);
    ninst = instanceIndices.size();

    if(inst_level == myInstanceAttribStack.entries())
        myInstanceAttribStack.append();

    myInstanceAttribStack(inst_level).nInst = ninst;
    
    // UTdebugPrint("Process instance level",
    //              inst_id, proto_id, inst_level, ninst);
    GT_DataArrayHandle ind_mapping;
    GT_AttributeListHandle alist = myInstanceAttribStack(inst_level).attribs;
    UT_StringMap<bool> exists;
    for (exint i = 0, n = descs.size(); i < n; ++i)
    {
        auto &name = descs[i].name;
        UT_StringHolder usd_attrib(name.GetText());
        auto entry = myExtraAttribs.find(usd_attrib);
        if(entry == myExtraAttribs.end())
            continue;

        GT_DataArrayHandle attr;
        if(HdChangeTracker::IsPrimvarDirty(*dirty_bits, inst_id, name) ||
           (*dirty_bits & (HdChangeTracker::DirtyInstancer |
                           HdChangeTracker::DirtyInstanceIndex)))
        {
            auto value = xinst->primvarValue(name);
            if(!value.IsEmpty())
            {
                attr = XUSD_HydraUtils::attribGT(value,
                                                 GT_TYPE_NONE,
                                                 XUSD_HydraUtils::newDataId());
                if(attr->entries() > ninst)
                {
                    if(!ind_mapping)
                    {
                        auto ind = new GT_DANumeric<int>(ninst,1);
                        for(int i=0; i<ninst; i++)
                            ind->set(instanceIndices[i], i);
                        ind_mapping = ind;
                    }
                    
                    attr = new GT_DAIndirect(ind_mapping, attr);
                }
            }
            // else
            //     UTdebugPrint("Empty attrib!");
        }
        
        
        if(!attr && alist)
            attr = alist->get(entry->second);
        
        if(attr)
        {
            exists[ entry->second ] = true;
            if(ninst < 0)
                ninst = attr->entries();
            if(alist)
                alist = alist->addAttribute(entry->second, attr, true);
            else
                alist = GT_AttributeList::createAttributeList(entry->second,
                                                              attr);
        }
    }

    if(alist)
    {
        UT_StringArray to_remove;
        for(int i=0; i<alist->entries(); i++)
            if(exists.find(alist->getNames()(i)) == exists.end())
                to_remove.append(alist->getNames()(i));
        alist = alist->removeAttributes(to_remove);
    }

    if(alist && alist->entries() > 0)
    {
        myInstanceAttribStack(inst_level).attribs = alist;

        UT_Array<UT_Options> *optlist  = 
            myInstanceAttribStack(inst_level).options;
        if(!optlist)
        {
            optlist = new UT_Array<UT_Options>();
            myInstanceAttribStack(inst_level).options = optlist;
        }
        
        optlist->entries(ninst);

        for(int i=0; i<ninst; i++)
        {
            UT_Options &opts = (*optlist)(i);

            for(int ai=0; ai<alist->entries(); ai++)
            {
                GT_DataArray *array = alist->get(ai).get();
                auto storage = array->getStorage();
                auto tsize = array->getTupleSize();
                auto &name = alist->getName(ai);
                
                bool is_int = false;
                bool is_float = false;
                
                if(storage == GT_STORE_UINT8 || storage == GT_STORE_INT16 ||
                   storage == GT_STORE_INT32 || storage == GT_STORE_INT64)
                    is_int = true;
                else if(storage == GT_STORE_REAL16 ||
                        storage == GT_STORE_REAL32 ||
                        storage == GT_STORE_REAL64)
                    is_float = true;
                else if(storage != GT_STORE_STRING)
                    continue;
                
                if(tsize == 1)
                {
                    if(is_int)
                        opts.setOptionI(name, array->getI64(i));
                    else if(is_float)
                        opts.setOptionF(name, array->getF64(i));
                    else
                        opts.setOptionS(name, array->getS(i));
                }
                else if(is_float)
                {
                    if(tsize == 2)
                    {
                        UT_Vector2D v( array->getF64(i,0),
                                       array->getF64(i,1));
                        opts.setOptionV2(name, v);
                    }
                    else if(tsize == 3)
                    {
                        UT_Vector3D v( array->getF64(i,0),
                                       array->getF64(i,1),
                                       array->getF64(i,2) );
                        opts.setOptionV3(name, v);
                    }
                    else if(tsize == 4)
                    {
                        UT_Vector4D v( array->getF64(i,0),
                                       array->getF64(i,1),
                                       array->getF64(i,2),
                                       array->getF64(i,3) );
                        opts.setOptionV4(name, v);
                    }
                }
                else if(is_int)
                {
                    UT_Int64Array v;
                    for(int it=0; it<tsize; it++)
                        v.append(array->getI64(i,it));
                    opts.setOptionIArray(name, v);
                }
                else
                {
                    UT_StringArray v;
                    for(int it=0; it<tsize; it++)
                        v.append(array->getS(i,it));
                    opts.setOptionSArray(name, v);
                }
            }
        }
    }
    else
        myInstanceAttribStack(inst_level).clear();

    return alist != nullptr;
}

void
XUSD_HydraGeoBase::buildShaderInstanceOverrides(
    HdSceneDelegate         *sd,
    HdRenderParam           *rparm,
    const SdfPath           &inst_id,
    const SdfPath           &proto_id,
    HdDirtyBits             *dirty_bits)
{
    bool has_overrides = false;
    auto xinst = sd->GetRenderIndex().GetInstancer(inst_id);
    int ninst = 1;
    int lvl = 0;
 
    //UTdebugPrint("Build instancers", inst_id);
    SdfPath id = inst_id;
    SdfPath pid = proto_id;
    while(xinst)
    {
        int num;
        if(processInstancerOverrides(sd, rparm, id, pid, dirty_bits, lvl, num))
            has_overrides = true;
        
        ninst *= num;

        pid = id;
        id = xinst->GetParentId();
        if(id.IsEmpty())
            break;
        
        xinst = sd->GetRenderIndex().GetInstancer(id);
        lvl++;
    }
    
    myHydraPrim.hasMaterialOverrides(has_overrides);

    if(has_overrides)
    {
        //UTdebugPrint("has overrides", ninst);
        auto overrides = new GT_DAIndexedString(ninst);
        myInstanceOverridesAttrib = overrides;
        
        if(lvl == 0)
        {
            // easy case, no nesting.
            const UT_Array<UT_Options> *opt_array =
                myInstanceAttribStack(0).options;
            
            UT_ASSERT(opt_array->entries() == ninst);
            for(int i=0; i<ninst; i++)
            {
                const UT_Options &opts = (*opt_array)(i);
                assignOverride(&opts, overrides, i);
            }
        }
        else
        {
            int idx = 0;
            processNestedOverrides(lvl, overrides, nullptr, idx);
            // should have filled the entire flat array.
            UT_ASSERT(idx == ninst);
        }
        
        if(!myInstanceMatID ||
           myInstanceMatID->entries() != myInstanceOverridesAttrib->entries())
        {
            const int n = myInstanceOverridesAttrib->entries();
            myInstanceMatID = new GT_DANumeric<int>(n, 1);
        }
    }
    else
        myInstanceOverridesAttrib = nullptr;
}

void
XUSD_HydraGeoBase::processNestedOverrides(int level,
                                          GT_DAIndexedString *overrides,
                                          const UT_Options *input_opt,
                                          int &index) const
{
    const int ninst = myInstanceAttribStack(level).nInst;
    auto opt_array = myInstanceAttribStack(level).options;

    //UTdebugPrint("Nested", level, ninst);
    for(int i=0; i<ninst; i++)
    {
        const UT_Options *opt = opt_array ? &(*opt_array)(i) : nullptr;
        UT_Options new_opt_set;
        const UT_Options *final_opt = nullptr;

        if(input_opt && input_opt->getNumOptions()>0 &&
           opt && opt->getNumOptions()>0)
        {
            new_opt_set.merge(*opt);
            new_opt_set.merge(*input_opt);

            final_opt = &new_opt_set;
        }
        else if(input_opt && input_opt->getNumOptions()>0)
            final_opt = input_opt;
        else if(opt && opt->getNumOptions()>0)
            final_opt = opt;
        else
            final_opt = &new_opt_set;

        if(level == 0)
        {
            assignOverride(final_opt, overrides, index);
            index++;
        }
        else
            processNestedOverrides(level-1, overrides, final_opt, index);
    }
}

void
XUSD_HydraGeoBase::assignOverride(const UT_Options *options,
                                  GT_DAIndexedString *overrides,
                                  int index) const
{
    UT_StringHolder val;
    if(options && options->getNumOptions())
    {
        UT_WorkBuffer sbuf;
        options->appendPyDictionary(sbuf);
        val = sbuf.buffer();
    }
    //UTdebugPrint(index, val);
    overrides->setString(index, 0, val);
}

void
XUSD_HydraGeoBase::buildTransforms(HdSceneDelegate *scene_delegate,
                                   HdRenderParam   *rparm,
				   const SdfPath  &proto_id,
				   const SdfPath  &instr_id,
				   HdDirtyBits    *dirty_bits,
                                   int             hou_proto_id)
{
    bool only_prim_transform = instr_id.IsEmpty();
    const bool dirty_indices =
        HdChangeTracker::IsInstanceIndexDirty(*dirty_bits, proto_id);
    
    if(!only_prim_transform &&
	(HdChangeTracker::IsInstancerDirty(*dirty_bits, proto_id) ||
         HdChangeTracker::IsTransformDirty(*dirty_bits, proto_id) ||
	 dirty_indices))
    {
	// Instance transforms
	auto xinst = UTverify_cast<XUSD_HydraInstancer *>(
	    scene_delegate->GetRenderIndex().GetInstancer(instr_id));
	if(xinst)
	{
            myInstancerPath = instr_id;
            
            int levels = xinst->GetInstancerNumLevels(
                                scene_delegate->GetRenderIndex(),
                                *myHydraPrim.rprim());
            myHydraPrim.instanceIDs().entries(0);
            auto array =
                xinst->computeTransformsAndIDs(proto_id, true,
                                               levels-1,
                                               myHydraPrim.instanceIDs(),
                                               &myHydraPrim.scene(),
                                               hou_proto_id, dirty_indices);
            // UTdebugPrint("#ids",myHydraPrim.instanceIDs().entries(),
            //              array.size(), "IDs:", myHydraPrim.instanceIDs());

            myInstanceTransforms =
                XUSD_HydraUtils::createTransformArray(array);
            myInstanceLevels.clear();
            //UTdebugPrint("#ids", myHydraPrim.instanceIDs().entries());

	    myInstanceId++;
            
	    auto tr =
		static_cast<XUSD_HydraTransforms*>(myInstanceTransforms.get());
	    tr->setDataId(myInstanceId);
	    myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::INSTANCE_CHANGE;
	    only_prim_transform = false;
	}
	else
	    only_prim_transform = true;
    }

    if(instr_id.IsEmpty() && !myInstancerPath.IsEmpty())
        myInstancerPath = SdfPath::EmptyPath();

    if (only_prim_transform)
    {
	if(myInstanceTransforms && myInstanceTransforms->entries() != 0)
	{
	    myInstanceTransforms.reset();
	    myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::INSTANCE_CHANGE;
	}
        myHydraPrim.instanceIDs().entries(0);
    }
}

static void
husdUpdateAttribList(GT_AttributeListHandle& attrib_list,
                     UT_StringHolder key,
                     const GT_DataArrayHandle& attr)
{
    if (attrib_list)
    {
        attrib_list = attrib_list->
            addAttribute(key, attr, true);
    }
    else
    {
        attrib_list =
            GT_AttributeList::createAttributeList(key, attr);
    }
}

void
XUSD_HydraGeoBase::performCPUComputation(
    const HdExtComputationPrimvarDescriptor &primd,
    HdSceneDelegate *scene_delegate,
    const TfToken &usd_attrib,
    GT_Type gt_type,
    const SdfPath &id,
    GT_DataArrayHandle &attr)
{
    HdExtComputationPrimvarDescriptorVector cvar;
    cvar.emplace_back(primd);
                 
    HdExtComputationUtils::ValueStore value_store
        = HdExtComputationUtils::GetComputedPrimvarValues(
            cvar, scene_delegate);
    auto val = value_store.find(usd_attrib);
    if (val != value_store.end())
    {
        auto id = XUSD_HydraUtils::newDataId();
        attr = XUSD_HydraUtils::attribGT(val->second,
                                         gt_type, id);
    }
}


bool
XUSD_HydraGeoBase::updateAttrib(
    const TfToken       &usd_attrib,
    const UT_StringRef  &gt_attrib,
    HdSceneDelegate     *sd,
    const SdfPath       &id,
    HdDirtyBits         *dirty_bits,
    GT_Primitive        *gt_prim,
    GT_AttributeListHandle (&attrib_list)[4],
    GT_Type              gt_type,
    int                 *point_freq_num,
    bool                set_point_freq,
    bool                *exists,
    GT_DataArrayHandle  vert_index,
    bool                perform_gpu_skinning,
    bool                *computed_retval)
{
    if(exists)
	*exists = false;
    
    auto entry = myAttribMap.find(usd_attrib.GetText());
    if(entry == myAttribMap.end())
	return false;
	
    GT_Owner attrib_owner = entry->second.myOwner;
    if(attrib_owner == GT_OWNER_INVALID)
	return false;

    const HdExtComputationPrimvarDescriptor *computation_info
            = entry->second.myComputationInfo.get();
    const bool computed = (computation_info != nullptr);

    bool changed = false;
    bool no_op = false;
    GT_DataArrayHandle attr;

    if (HdChangeTracker::IsPrimvarDirty(*dirty_bits, id, usd_attrib))
    {
    	if (computed)
    	{
            XUSD_HydraExtComputation *source_comp =
                UTverify_cast<XUSD_HydraExtComputation*>(
                sd->GetRenderIndex().GetSprim(HdPrimTypeTokens->extComputation,
                computation_info->sourceComputationId));
            if (perform_gpu_skinning)
            {
                if (source_comp->isSkinning(sd))
                {
                    husdUpdateAttribList(attrib_list[GT_OWNER_CONSTANT],
                                         GT_Names::rig_transforms,
                                         source_comp->getSkinningXformAttr());
                    husdUpdateAttribList(attrib_list[GT_OWNER_POINT],
                                         GT_Names::boneIndex,
                                         source_comp->getBoneIdxAttr());
                    husdUpdateAttribList(attrib_list[GT_OWNER_POINT],
                                         GT_Names::boneWeight,
                                         source_comp->getBoneWeightAttr());
                }
                if (source_comp->isBlendShape(sd))
                {
                    husdUpdateAttribList(attrib_list[GT_OWNER_CONSTANT],
                                         GT_Names::blend_shape_weights,
                                         source_comp->getBlendShapeWeightAttr());
                    husdUpdateAttribList(attrib_list[GT_OWNER_POINT],
                                         GT_Names::blend_shape_offsets,
                                         source_comp->getBlendShapeOffsetsAttr());
                }
                attr = source_comp->getRestPointsAttr();
            }
            else
            {
                // UTdebugPrint("CPU");
                performCPUComputation(*computation_info, sd, usd_attrib,
                                      gt_type, id, attr);
            }
            changed = true;
    	}
    	else
    	{
    	    attr = XUSD_HydraUtils::attribGT(sd->Get(id,usd_attrib),
    					     gt_type,
    					     XUSD_HydraUtils::newDataId());
    	}

    	if(attr)
    	{
    	    myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::GEO_CHANGE;
    	    changed = true;
    	}
    }

    if(!attr)
    {
        // Houdini viewport doesn't natively support primitive normals, they are
        // upcast to vertex attribs.
        if(gt_attrib == GA_Names::N && attrib_owner == GT_OWNER_PRIMITIVE)
            attrib_owner = GT_OWNER_VERTEX;
        
        if(gt_prim && gt_prim->getAttributeList(attrib_owner))
        {
            attr = gt_prim->getAttributeList(attrib_owner)->get(gt_attrib);

            // Unroll to the original attribute, if there was an indirection
            // added later on in Sync().
            GT_DAIndirect *itr = nullptr;
            do
            {
                itr = dynamic_cast<GT_DAIndirect*>(attr.get());
                if(itr)
                  attr = itr->referencedData();
            } while(itr);

            no_op = true;
        }
    }
    

    if(attr && attr->entries() > 0)
    {
	// Some pixar meshes have #vertices == #points, which is very
	// different from how our polymeshes work. Change them to point
	// frequency.
	if(set_point_freq && point_freq_num)
	    *point_freq_num = attr->entries();

        if(attrib_owner == GT_OWNER_VERTEX && vert_index)
        {
            if(vert_index->entries() > attr->entries() )
            {
                return false;
            }
            else if(vert_index->entries() < attr->entries() )
            {
                // possibly due to convexing, so unroll it to get the original
                GT_DAInherit *inh = dynamic_cast<GT_DAInherit*>(attr.get());
                while(inh)
                {
                    attr = inh->referencedData();
                    inh = dynamic_cast<GT_DAInherit*>(attr.get());
                }
                
                if(vert_index->entries() < attr->entries() )
                {
                    // some other issue; array is too long.
                    attr = new GT_DASubArray(attr, 0, vert_index->entries());
                    attr = attr->harden();
                }
            }
        }

        if(!computed && !no_op)
            attr = attr->harden();
	
        husdUpdateAttribList(attrib_list[attrib_owner], gt_attrib, attr);

	if(exists)
	    *exists = true;
        if(computed_retval)
            *computed_retval = computed;

    }
    return changed;
}

void
XUSD_HydraGeoBase::createInstance(HdSceneDelegate          *scene_delegate,
				  const SdfPath		   &proto_id,
				  const SdfPath		   &inst_id,
				  HdDirtyBits		   *dirty_bits,
				  GT_Primitive		   *geo,
                                  const GfRange3d          *extents,
				  GEO_ViewportLOD	    lod,
				  int			    mat_id,
				  bool			    instance_change,
                                  bool                      add_bbox)
{
#if 0
    static UT_Lock theLock;
    UT_AutoLock lock(theLock);
#endif

    if(!inst_id.IsEmpty())
        myHydraPrim.setPath(
            myHydraPrim.getTopLevelPath(scene_delegate, proto_id, inst_id) );

    GT_AttributeListHandle detail, uniform;

    // render pass token
    HUSD_HydraPrim::RenderTag tag = HUSD_HydraPrim::renderTag(
					scene_delegate->GetRenderTag(proto_id));
    myHydraPrim.setRenderTag(tag);

    // lod
    auto loda = new GT_DAConstantValue<int>(1, 1<<lod);
    detail = GT_AttributeList::createAttributeList(GT_Names::view_lod_mask,
						   loda);
    // nested instancing
    if(myInstanceLevels.entries())
    {
        //UTdebugPrint("Set instance levels on packed");
        auto ilvl = new GT_DANumeric<int>(myInstanceLevels.array(),
                                          myInstanceLevels.entries(), 1);
        //ilvl->dumpValues("XUSD_HydraGeoPrim");
        detail = detail->addAttribute(GT_Names::instancelevels, ilvl, true);
    }

    int ntransforms = myInstanceTransforms ? myInstanceTransforms->entries():1;

    auto lodu = new GT_DAConstantValue<int>(ntransforms, lod);
    uniform = GT_AttributeList::createAttributeList(GT_Names::view_lod, lodu);

    const int nt = myInstanceTransforms ? myInstanceTransforms->entries() : 1;
    auto &&inames = myHydraPrim.instanceIDs();

    myHydraPrim.setInstanced(nt > 1);

    // Prim IDs
    if(instance_change || !myPickIDArray)
    {
	if(inames.entries() == 0)
	{
	    // identifer
	    myPickIDArray = new GT_DAConstantValue<int>(1, myHydraPrim.id());
	    mySelection   = new GT_DAConstantValue<int>(1, 0);
	}
	else
	{
	    myPickIDArray = new GT_DANumeric<int>(inames.array(), nt, 1);
	    auto sel = new GT_DANumeric<int>(nt,1);
	    memset(sel->data(), 0, sizeof(int)*nt);
	    mySelection = sel;
	}
    }
    
    detail = detail->addAttribute(GT_Names::lop_pick_id, myPickIDArray, true);
    uniform = uniform->addAttribute(GT_Names::selection, mySelection, true);
    if(myInstanceOverridesAttrib)
    {
        uniform = uniform->addAttribute(
            GA_Names::material_override, myInstanceOverridesAttrib, true);

        uniform = uniform->addAttribute("MatID", myInstanceMatID, true);
    }

    
    // BBox
    if(add_bbox)
    {
        if(!addBBoxAttrib(scene_delegate, proto_id, detail, geo, extents))
            addBBoxAttrib(scene_delegate, inst_id, detail, geo, extents);
    }

    if(mat_id != -1)
    {
	auto matda = new GT_DAConstantValue<int>(1, mat_id);
	detail = detail->addAttribute("MatID", matda, true);
	//UTdebugPrint("assign material", mat_id);
    }

    // Check light categories. MaterialId seems to get sent intstead of
    // Categories, but check both
    if((*dirty_bits & HdChangeTracker::DirtyCategories) ||
       (*dirty_bits & HdChangeTracker::DirtyMaterialId)) 
    {
        myLightLink.clear();
        myShadowLink.clear();
        
        VtArray<TfToken> categories;
        auto &scene = myHydraPrim.scene();
        
        categories = scene_delegate->GetCategories(proto_id);
        for (TfToken const& category: categories)
        {
            UT_StringHolder link(category.GetText());
            if(scene.isCategory(link, HUSD_Scene::CATEGORY_LIGHT))
                myLightLink.append(link);
            if(scene.isCategory(link, HUSD_Scene::CATEGORY_SHADOW))
                myShadowLink.append(link);
        }
        
        if(!inst_id.IsEmpty())
        {
            categories = scene_delegate->GetCategories(inst_id);
            for (TfToken const& category: categories)
            {
                UT_StringHolder link(category.GetText());
                if(scene.isCategory(link, HUSD_Scene::CATEGORY_LIGHT))
                    myLightLink.append(link);
                if(scene.isCategory(link, HUSD_Scene::CATEGORY_SHADOW))
                    myShadowLink.append(link);
            }
        }
        
	myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::LIGHT_LINK_CHANGE;
    }

    auto llda = new GT_DAIndexedString(myLightLink.entries());
    for(int i=0; i<myLightLink.entries(); i++)
        llda->setString(i, 0, myLightLink(i));
    
    detail = detail->addAttribute("__lightlink", llda, true);
    
    auto slda = new GT_DAIndexedString(myShadowLink.entries());
    for(int i=0; i<myShadowLink.entries(); i++)
        slda->setString(i, 0, myShadowLink(i));
    
    detail = detail->addAttribute("__shadowlink", slda, true);

    // create the container packed prim.
    myInstance = new GT_PrimInstance(geo, myInstanceTransforms,
				     GT_GEOOffsetList(), // no offsets exist.
				     uniform,  detail);

    myGTPrimTransform->setMatrix(myPrimTransform, 0);
    geo->setPrimitiveTransform(myGTPrimTransform);
    myGTPrim = geo;

    if(myHydraPrim.index() == -1)
	myHydraPrim.scene().addDisplayGeometry(&myHydraPrim);
}

void
XUSD_HydraGeoBase::removeFromDisplay(HdSceneDelegate *scene_delegate,
                                     const SdfPath &proto_id,
                                     const SdfPath &instr_id)
{
    if(myHydraPrim.isConsolidated())
        myHydraPrim.scene().removeConsolidatedPrim(myHydraPrim.id());
    
    if(myHydraPrim.index() != -1)
	myHydraPrim.scene().removeDisplayGeometry(&myHydraPrim);
}

// -------------------------------------------------------------------------

XUSD_HydraGeoMesh::XUSD_HydraGeoMesh(TfToken const& type_id,
				     SdfPath const& prim_id,
				     GT_PrimitiveHandle &gt_prim,
				     GT_PrimitiveHandle &instance,
				     int &dirty,
				     XUSD_HydraGeoPrim &hprim)
    : HdMesh(prim_id),
      XUSD_HydraGeoBase(gt_prim, instance, dirty, hprim),
      myTopHash(0),
      myIsSubD(false),
      myIsLeftHanded(true),
      myVaryingPrim(false),
      myMaterialsNeedTangents(false),
      myGeometryNeedTangents(false),
      myRefineLevel(0),
      myTangentDataID(-1)
{
}

XUSD_HydraGeoMesh::~XUSD_HydraGeoMesh()
{
    resetPrim();
}
  
void
XUSD_HydraGeoMesh::Finalize(HdRenderParam *renderParam)
{
    if(myHydraPrim.isConsolidated())
    {
        myHydraPrim.scene().removeConsolidatedPrim(myHydraPrim.id());
        myHydraPrim.setConsolidated(false);
    }
    if(!myInstancerPath.IsEmpty())
        myInstancerPath = SdfPath::EmptyPath();

    HdRprim::Finalize(renderParam);
}

HdDirtyBits
XUSD_HydraGeoMesh::GetInitialDirtyBitsMask() const
{
    return HdChangeTracker::AllDirty;
}

HdDirtyBits
XUSD_HydraGeoMesh::_PropagateDirtyBits(HdDirtyBits bits) const
{
    return bits;
}

void
XUSD_HydraGeoMesh::_InitRepr(TfToken const &representation,
			     HdDirtyBits *dirty_bits)
{
}

void
XUSD_HydraGeoMesh::Sync(HdSceneDelegate *scene_delegate,
			HdRenderParam *rparm,
			HdDirtyBits *dirty_bits,
			TfToken const &representation)
{
    SdfPath const	&id = GetId();

    if(isDeferred(id, scene_delegate, rparm, *dirty_bits))
    {
        if(myHydraPrim.index() == -1)
            myHydraPrim.scene().addDisplayGeometry(&myHydraPrim);
	return;
    }

    UT_AutoLock prim_lock(myHydraPrim.lock());
    
    myDirtyMask = 0;
    *dirty_bits |= myPrevDirtyBits;
    
    GEO_ViewportLOD lod = checkVisibility(scene_delegate, id, dirty_bits);
    if(lod == GEO_VIEWPORT_HIDDEN)
    {
        clearDirty(dirty_bits, HOLD_DIRTY_BITS);
	removeFromDisplay(scene_delegate, id, GetInstancerId());
	return;
    }

#if 0
    static UT_Lock theDebugLock;
    UT_AutoLock locker(theDebugLock);
    UTdebugPrint("Sync", id.GetText(), myHydraPrim.id(),
                  GetInstancerId().IsEmpty() ? "" : "instanced",
                  GetInstancerId().GetText());
    HdChangeTracker::DumpDirtyBits(*dirty_bits);
#endif

    if(!myHydraPrim.isInitialized())
    {
        // Cache the varying bit as Hydra will send Varying on subsequent updates
        // and remove meshes from the consolidated mesh, degrading performance
        // over time.
        myVaryingPrim = HdChangeTracker::IsVarying(*dirty_bits);
    }
     
    GT_Primitive       *gt_prim = myGTPrim.get();
    int64		top_id = 1;
    UT_Array<GT_PrimSubdivisionMesh::Tag> subd_tags;

    // Materials
    bool		dirty_materials = false;

    if(*dirty_bits & HdChangeTracker::DirtyMaterialId)
    {
	SdfPath mat_id = scene_delegate->GetMaterialId(GetId());

	SetMaterialId(mat_id);

        // Clear out all materials and material parms
        myExtraAttribs.clear();
        myExtraUVAttribs.clear();

        for(auto matref : myHydraPrim.materialReferences())
        {
            auto entry = myHydraPrim.scene().materials().find(matref);
            if(entry != myHydraPrim.scene().materials().end())
                entry->second->removePrimRef(myHydraPrim.id());
        }
        
        myHydraPrim.clearMaterials();
        
        const int prev_mat = myMaterialID;
        myMaterialID = -1;
        myMaterials.clear();
        myMaterialsNeedTangents = false;
        myMaterialsNeedObjectSpace = false;

        if(!mat_id.IsEmpty())
        {
            HUSD_Path path(mat_id);
            auto entry = myHydraPrim.scene().materials().find(path);
            if(entry != myHydraPrim.scene().materials().end())
            {
                auto &hmat = entry->second;
                if(hmat->isValid())
                {
                    // ensure these attribs are present on the geometry.
                    for(auto &it : hmat->requiredUVs())
                        myExtraUVAttribs[it.first] = it.first;
                    for(auto &it : hmat->shaderParms())
                        myExtraAttribs[it.second] = it.first;

                    myMaterialID = hmat->getMaterialID();
                    myMaterials.append(path);

                    if(hmat->needsTangents())
                        myMaterialsNeedTangents = true;
                    if(hmat->needsObjectSpace())
                        myMaterialsNeedObjectSpace = true;

                    // Link the material and the prim
                    hmat->addPrimRef(myHydraPrim.id());
                    myHydraPrim.addMaterialRef(hmat->path());
                }
            }
        }

        if(myMaterialID != prev_mat)
            myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::MAT_CHANGE;
        
	dirty_materials = true;
    }

    // Available attributes
    if(!gt_prim || myAttribMap.size() == 0 ||
       (*dirty_bits & HdChangeTracker::DirtyPrimvar) ||
       	HdChangeTracker::IsTopologyDirty(*dirty_bits, id))
    {
	XUSD_HydraUtils::buildAttribMap(scene_delegate, id, myAttribMap);
    }


    // Instancing
    GT_TransformHandle th;
    
    // Transforms
    if (!gt_prim || HdChangeTracker::IsTransformDirty(*dirty_bits, id))
    {
	myPrimTransform =
            GusdUT_Gf::Cast(GfMatrix4d(scene_delegate->GetTransform(id)));
	myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::INSTANCE_CHANGE;
    }
    
    // Topology
    if(gt_prim && gt_prim->getDetailAttributes())
    {
	auto top = gt_prim->getDetailAttributes()->get(GT_Names::topology);
	if(top)
	    top_id = top->getI64(0);
    }

    bool need_gt_update = (!myVertex || !gt_prim || myCounts.entries()==0);

    if (need_gt_update || dirty_materials ||
	HdChangeTracker::IsTopologyDirty(*dirty_bits, id))
    {
        TF_DEBUG(USDIMAGING_CHANGES).Msg(
            "[HUSD Updating Topology] Mesh path: <%s>\n",
            GetId().GetText());
	auto &&top = HdMeshTopology(GetMeshTopology(scene_delegate), 0);
	
	if(HdChangeTracker::IsTopologyDirty(*dirty_bits, id))
	{
	    int64 top_hash = top.ComputeHash();

	    myIsLeftHanded = (top.GetOrientation() != HdTokens->rightHanded);
	
	    if(need_gt_update || top_hash != myTopHash)
	    {
		myTopHash = top_hash;
		if(top.GetNumPoints() > 0)
		{
                    auto &&fcount = top.GetFaceVertexCounts();
                    auto &&vcount = top.GetFaceVertexIndices();
                    const exint max_pnt_idx = top.GetNumPoints()-1;
                    const exint max_vert = top.GetNumFaceVaryings();

                    if(top.GetHoleIndices().size() == 0)
                    {
                        myCounts.init(new GT_DAClampedArray(
                          XUSD_HydraUtils::createGTArray(fcount),0,max_vert));
                        myVertex = new GT_DAClampedArray(
                          XUSD_HydraUtils::createGTArray(vcount),0,max_pnt_idx);
                        myVertexIndirect.reset();
                        myPrimIndirect.reset();
                    }
                    else // Missing faces due to holes
                    {
                        const exint nfaces = top.GetNumFaces();
                        UT_IntArray hide_faces(nfaces, nfaces);
                        hide_faces.zero();

                        for(auto idx : top.GetHoleIndices())
                            if(idx >= 0 && idx < nfaces)
                                hide_faces(idx) = 1;

                        auto counts = new GT_DANumeric<int>(0,1);
                        auto verts  = new GT_DANumeric<int>(0,1);
                        auto vindirect = new GT_DANumeric<int>(0,1);
                        auto pindirect = new GT_DANumeric<int>(0,1);

                        exint vidx = 0;
                        for(exint i=0; i<nfaces; i++)
                        {
                            const exint nverts = fcount[i];
                            if(!hide_faces(i))
                            {
                                counts->append(nverts);
                                pindirect->append(i);
                                for(exint v = 0; v<nverts; v++, vidx++)
                                {
                                    verts->append(vcount[vidx]);
                                    vindirect->append(vidx);
                                }
                            }
                            else
                                vidx += nverts;
                        }
                        myCounts.init(counts);
                        myVertex = verts;
                        myVertexIndirect = vindirect;
                        myPrimIndirect = pindirect;
                    }
                    
		    if (top.GetScheme()==PxOsdOpenSubdivTokens->catmullClark)
			myIsSubD = true;
		    else
			myIsSubD = false;
		}
		else
		{
		    myCounts.clear();
		    myVertex.reset();
                    myVertexIndirect.reset();
                    myPrimIndirect.reset();
		    myIsSubD = false;
		}
		top_id = XUSD_HydraUtils::newDataId();
                if(gt_prim && gt_prim->getDetailAttributes())
                {
                    auto top = gt_prim->getDetailAttributes()->get(GT_Names::topology);
                    if(top)
                    {
                        auto top_da = dynamic_cast<GT_DAConstantValue<int64> *>
                            (top.get());
                        if(top_da)
                            top_da->set(top_id);
                    }
                }
                    
		myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::TOP_CHANGE;
	    }
	}
	
	if(dirty_materials)
	{
	    auto &subsets = top.GetGeomSubsets();
	    if(subsets.size() > 0)
	    {
                UT_Map<int,int> materials;
		auto matid_da = new GT_DANumeric<int>(top.GetNumFaces(), 1);
		memset(matid_da->data(), 0xFF, matid_da->entries()*sizeof(int));
		
		for(auto &subset : subsets)
		{
                    HUSD_Path matname(subset.materialId);

		    // UTdebugPrint("Subset name", subset.id.GetText());
		    // UTdebugPrint("Material =", mapname);
		    // UTdebugPrint("# faces =", subset.indices.size());
		    auto entry = myHydraPrim.scene().materials().find(matname);
		    if(entry != myHydraPrim.scene().materials().end())
		    {
			auto &hmat = entry->second;
			// ensure these attribs are present on the generated
			// geometry.
			for(auto &it : hmat->requiredUVs())
			    myExtraUVAttribs[it.first] = it.first;
                        for(auto &it : hmat->shaderParms())
                            myExtraAttribs[it.second] = it.first;
                        
			int matid = hmat->isValid() ? hmat->getMaterialID() :-1;
			for(auto index : subset.indices)
                        {
                            if(index < matid_da->entries())
                                matid_da->set(matid, index);
                        }
                        // Link the mateiral and the prim
                        hmat->addPrimRef(myHydraPrim.id());
                        myHydraPrim.addMaterialRef(hmat->path());

                        materials[ matid] = 1;
                        myMaterials.append(matname);
                        if(hmat->needsTangents())
                            myMaterialsNeedTangents = true;
                        if(hmat->needsObjectSpace())
                            myMaterialsNeedObjectSpace = true;
		    }
		}
                auto mats_da = new GT_DANumeric<int>(materials.size(), 1);
                int *data = mats_da->data();
                for(auto it : materials)
                    *data++ = it.first;
                
		myMatIDArray = matid_da;
                myMaterialsArray = mats_da;
                myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::MAT_CHANGE;
	    }
	    else
            {
                if(myMatIDArray)
                {
                    myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::MAT_CHANGE;
                    myMatIDArray.reset();
                    myMaterialsArray.reset();
                }
            }
	}
    }

    if(!myVertex || myCounts.entries() == 0)
    {
	myInstance.reset();
	myGTPrim.reset();
	clearDirty(dirty_bits, HOLD_DIRTY_BITS);
	removeFromDisplay(scene_delegate, id, GetInstancerId());
	return;
    }

    // Make sure our instancer and it's parent instancers are synced.
    _UpdateInstancer(scene_delegate, dirty_bits);
    HdInstancer::_SyncInstancerAndParents(
        scene_delegate->GetRenderIndex(), GetInstancerId());

    if(!GetInstancerId().IsEmpty())
    {
        buildShaderInstanceOverrides(scene_delegate,
                                     rparm,
                                     GetInstancerId(),
                                     id, dirty_bits);
    }
    else
    {
        myHydraPrim.hasMaterialOverrides(false);
        myInstanceAttribList = nullptr;
        myInstanceOverridesAttrib = nullptr;
        myInstanceMatID = nullptr;
        myInstanceTransforms = nullptr;
    }

    buildTransforms(scene_delegate, rparm, id, GetInstancerId(), dirty_bits,
                    myHydraPrim.id());
    if(myInstanceTransforms && myInstanceTransforms->entries() == 0)
    {
        // zero instance transforms means nothing should be displayed.
        removeFromDisplay(scene_delegate, id, GetInstancerId());
        clearDirty(dirty_bits, HOLD_DIRTY_BITS);
        return;
    }
        
    if(*dirty_bits & HdChangeTracker::DirtyDisplayStyle)
	myRefineLevel = scene_delegate->GetDisplayStyle(id).refineLevel;
    
    if(*dirty_bits & HdChangeTracker::DirtyExtent)
        myExtents = scene_delegate->GetExtent(id);

    if (HdChangeTracker::IsSubdivTagsDirty(*dirty_bits, id) &&
	myIsSubD &&
	myRefineLevel > 0)
    {
	XUSD_HydraUtils::processSubdivTags(
	    scene_delegate->GetSubdivTags(id), subd_tags);
    }

#ifdef CONSOLIDATE_SMALL_MESHES
    bool consolidate_mesh = false;
    if(!myVaryingPrim &&
       !myMaterialsNeedObjectSpace &&
        myMaterials.entries() <= 1 &&
       myVertex->entries() < SMALL_MESH_MAX_VERTS)
    {
        if(myInstanceTransforms)
        {
            if(myInstanceTransforms->entries() == 1)
                consolidate_mesh = true;
            else 
            {
                exint verts = myVertex->entries();
                exint total = (myInstanceTransforms->entries() * verts);

                if(total < SMALL_MESH_INSTANCE_LIMIT)
                {
                    if(fpreal(total)/fpreal(verts)<SMALL_MESH_UNROLL_MEM_LIMIT)
                    {
                        // UTdebugPrint("#inst",myInstanceTransforms->entries(),
                        //               myVertex->entries());
                        consolidate_mesh = true;
                    }
                    // else
                    //     UTdebugPrint(total, "Exceeded",
                    //                  fpreal(total)/fpreal(verts));
                }
            }
        }
        else
            consolidate_mesh = true;
    }
    // else if(myMaterials.entries() > 1)
    //     UTdebugPrint("Too many materials");
    // else if(myVaryingPrim)
    //     UTdebugPrint("Varying");
    // else
    //     UTdebugPrint("Too many verts", myVertex->entries());
    
#else
    const bool consolidate_mesh = false;
#endif


#ifdef GPU_MESH_DEFORMATION
    bool perform_gpu_skinning = true;
#else
    bool perform_gpu_skinning = false;
#endif

    XUSD_HydraExtComputation *skinning_comp = nullptr;
    if (auto it = myAttribMap.find(HdTokens->points.GetText());
        it != myAttribMap.end() &&
        perform_gpu_skinning &&
        it->second.myComputationInfo != nullptr)
    {
        auto points_comp = UTverify_cast<XUSD_HydraExtComputation *>(
                scene_delegate->GetRenderIndex().GetSprim(
                        HdPrimTypeTokens->extComputation,
                        it->second.myComputationInfo->sourceComputationId));

        perform_gpu_skinning = points_comp->isSkinning(scene_delegate)
                               || points_comp->isBlendShape(scene_delegate);
        consolidate_mesh = consolidate_mesh && !perform_gpu_skinning;

        if (perform_gpu_skinning)
            skinning_comp = points_comp;
    }
    else
	perform_gpu_skinning = false;

    // Populate attributes
    GT_AttributeListHandle attrib_list[GT_OWNER_MAX];

    const bool has_n = (myAttribMap.find(HdTokens->normals.GetText()) !=
                        myAttribMap.end());

    if (!consolidate_mesh)
    {
        auto wnd = new GT_DAConstantValue<int>(1, myIsLeftHanded?0:1, 1);
        auto top = new GT_DAConstantValue<int64>(1, top_id, 1);
        auto nmlgen = new GT_DAConstantValue<int>(1, !has_n, 1);
        attrib_list[GT_OWNER_DETAIL] =
          GT_AttributeList::createAttributeList(GT_Names::topology,top,
                                                GT_Names::winding_order,wnd,
                                                GT_Names::nml_generated,nmlgen);
    }
    
    int point_freq = 0;
    bool pnt_exists = false;
    bool computed_P = false;
    
    updateAttrib(HdTokens->points, "P"_sh, scene_delegate, id, dirty_bits,
		 gt_prim, attrib_list, GT_TYPE_POINT, &point_freq, true,
                 &pnt_exists, myVertex, perform_gpu_skinning, &computed_P);

    if(!pnt_exists)
    {
	myInstance.reset();
	myGTPrim.reset();
	clearDirty(dirty_bits, HOLD_DIRTY_BITS);
	removeFromDisplay(scene_delegate, id, GetInstancerId());
	return;
    }

    // Mesh Sanity check.
    const GT_DataArrayHandle &pdata = attrib_list[GT_OWNER_POINT]->get("P");
    if(pdata->entries() < 3)
    {
	myInstance.reset();
	myGTPrim.reset();
	clearDirty(dirty_bits, HOLD_DIRTY_BITS);
	removeFromDisplay(scene_delegate, id, GetInstancerId());
	return;
    }

    // additional, optional attributes
    updateAttrib(HdTokens->displayColor, "Cd"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
		 GT_TYPE_COLOR, &point_freq, false, nullptr, myVertex);
    bool normal_exists = false;
    updateAttrib(HdTokens->normals, "N"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
		 GT_TYPE_NORMAL, &point_freq, false, &normal_exists, myVertex);
    updateAttrib(HdTokens->displayOpacity, "Alpha"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                 GT_TYPE_NONE, &point_freq, false, nullptr, myVertex);
    static TfToken tangentu("tangentu");
    static TfToken tangentv("tangentv");
    bool tanu_exists =false, tanv_exists = false;
    updateAttrib(tangentu, GT_Names::tangentu,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                 GT_TYPE_NONE, &point_freq, false, &tanu_exists, myVertex);
    updateAttrib(tangentv, GT_Names::tangentv,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                 GT_TYPE_NONE, &point_freq, false, &tanv_exists, myVertex);

    GfRange3d extents = myExtents;

    // If P is a computed primvar, the authored extents are not expected to
    // reflect the new point positions and should be recomputed.
    // For GPU skinning this would compute the extents of the rest points, so we
    // instead provide approximate bounds for the skinned result.
    // TODO - use the SkelRoot prim's extents if available, following
    // https://openusd.org//dev/api/_usd_skel__schemas.html#UsdSkel_SkelRoot
    bool add_bbox = !computed_P;
    if (perform_gpu_skinning)
    {
        UT_ASSERT(skinning_comp);
        const UT_BoundingBox &skinned_bounds
                = skinning_comp->getSkinnedBounds();

        extents = GfRange3d(
                GusdUT_Gf::Cast(skinned_bounds.minvec()),
                GusdUT_Gf::Cast(skinned_bounds.maxvec()));
        add_bbox = true;
    }

    // If we are performing gpu skinning, and the rest points and topology have
    // not changed, we may be able to reuse the normals from the previous frame
    if (gt_prim && perform_gpu_skinning
	&& attrib_list[GT_OWNER_POINT]->get(GA_Names::P)->getDataId()
           == gt_prim->getPointAttributes()->get(GA_Names::P)->getDataId()
    	&& gt_prim->getDetailAttributes()->get(GT_Names::topology)->getI64(0)
           == top_id)
    {
	// check to see if we can reuse the normals
	if (!normal_exists
	    && gt_prim->getPointAttributes()
	    && gt_prim->getPointAttributes()->get(GA_Names::N))
	{
	    auto normal = gt_prim->getPointAttributes()->get(GA_Names::N);
    	    husdUpdateAttribList(attrib_list[GT_OWNER_POINT], GA_Names::N, normal);
	}
    }


    myGeometryNeedTangents = (!tanu_exists && !tanv_exists);
#if 0
    if(myAttribMap.find("cardsUv"_sh) != myAttribMap.end())
    {
        updateAttrib(TfToken("cardsUv"), "uv"_sh,
                     scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                     GT_TYPE_TEXTURE, nullptr, true);
        updateAttrib(TfToken("cardsTexAssign"), "tex"_sh,
                     scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                     GT_TYPE_NONE, nullptr, true);
    }
#endif
    for(auto &itr : myExtraAttribs)
    {
	auto &attrib = itr.first;
	auto entry = myAttribMap.find(attrib);
	if(entry != myAttribMap.end())
	{
	    TfToken htoken(attrib);
	    updateAttrib(htoken, attrib, scene_delegate, id,
			 dirty_bits, gt_prim, attrib_list, GT_TYPE_NONE,
                         &point_freq, false, nullptr, myVertex);
	}
    }
    
    bool uv_attempted = false;
    bool st_attempted = false;
    for(auto &itr : myExtraUVAttribs)
    {
	auto &attrib = itr.first;
        // Don't attempt to refill if this attrib was already in myExtraAttribs.
        if(myExtraAttribs.find(attrib) != myExtraAttribs.end())
            continue;

	auto entry = myAttribMap.find(attrib);
	if(entry != myAttribMap.end())
	{
	    TfToken htoken(attrib);
	    updateAttrib(htoken, attrib, scene_delegate, id,
			 dirty_bits, gt_prim, attrib_list, GT_TYPE_NONE,
                         &point_freq, false, nullptr, myVertex);
	}
        else 
        {
            UT_StringHolder gt_attrib;
            if(attrib == "uv" && !st_attempted)
            {
                TfToken htoken("st");
                gt_attrib = "st";
                st_attempted = true;
                updateAttrib(htoken, gt_attrib, scene_delegate, id,
                             dirty_bits, gt_prim, attrib_list, GT_TYPE_NONE,
                             &point_freq, false, nullptr, myVertex);
            }
            else if(attrib == "st" && !uv_attempted)
            {
                TfToken htoken("uv");
                gt_attrib = "uv";
                updateAttrib(htoken, gt_attrib, scene_delegate, id,
                             dirty_bits, gt_prim, attrib_list, GT_TYPE_NONE,
                             &point_freq, false, nullptr, myVertex);
                uv_attempted = true;
            }
         }
    }
                 
    if(myMatIDArray)
    {
	if(attrib_list[GT_OWNER_UNIFORM])
	    attrib_list[GT_OWNER_UNIFORM] = attrib_list[GT_OWNER_UNIFORM]
		->addAttribute("MatID"_sh, myMatIDArray, true);
	else
	    attrib_list[GT_OWNER_UNIFORM] =
		GT_AttributeList::createAttributeList("MatID"_sh, myMatIDArray);

	if(attrib_list[GT_OWNER_DETAIL])
            attrib_list[GT_OWNER_DETAIL] = attrib_list[GT_OWNER_DETAIL]
		->addAttribute("materials"_sh, myMaterialsArray, true);
	else
	    attrib_list[GT_OWNER_DETAIL] =
		GT_AttributeList::createAttributeList("materials"_sh,
                                                      myMaterialsArray);
    }

    // uniform and detail normals aren't supported by the renderer.
    // convert to vertex and point normals instead.
    if(attrib_list[GT_OWNER_UNIFORM] &&
       attrib_list[GT_OWNER_UNIFORM]->get(GA_Names::N))
    {
	GT_DataArrayHandle nml=attrib_list[GT_OWNER_UNIFORM]->get(GA_Names::N);
	const int nprim = myCounts.entries();
	const int nvert = myVertex->entries();
	auto index = new GT_DANumeric<int>(nvert, 1);
	int *data = index->data();
	int idx = 0;
	for(int i=0; i<nprim; i++)
	{
	    const int count = myCounts.getCount(i);
	    for(int j=0; j<count && idx<nvert; j++,idx++)
		data[idx] = i;
	}

	GT_DataArrayHandle indexh = index;
	GT_DataArrayHandle nh = new GT_DAIndirect(index, nml);
	if(attrib_list[GT_OWNER_VERTEX])
	{
	    attrib_list[GT_OWNER_VERTEX] = 
		attrib_list[GT_OWNER_VERTEX]->addAttribute(GA_Names::N,nh,true);
	}
	else
	    attrib_list[GT_OWNER_VERTEX] = 
		GT_AttributeList::createAttributeList(GA_Names::N,nh);
	
	attrib_list[GT_OWNER_UNIFORM]
	    = attrib_list[GT_OWNER_UNIFORM]->removeAttribute(GA_Names::N);
    }
    else if(attrib_list[GT_OWNER_DETAIL] &&
	    attrib_list[GT_OWNER_DETAIL]->get(GA_Names::N))
    {
	GT_DataArrayHandle nml=attrib_list[GT_OWNER_DETAIL]->get(GA_Names::N);
	GT_DataArrayHandle nh = new GT_DAConstant(nml, 0, point_freq);
	
	attrib_list[GT_OWNER_POINT] = 
	    attrib_list[GT_OWNER_POINT]->addAttribute(GA_Names::N,nh, true);

	attrib_list[GT_OWNER_DETAIL] =
	    attrib_list[GT_OWNER_DETAIL]->removeAttribute(GA_Names::N);

    }

    if(attrib_list[GT_OWNER_UNIFORM] && myPrimIndirect)
        attrib_list[GT_OWNER_UNIFORM] = attrib_list[GT_OWNER_UNIFORM]->
            createIndirect(myPrimIndirect);
    if(attrib_list[GT_OWNER_VERTEX] && myVertexIndirect)
        attrib_list[GT_OWNER_VERTEX] = attrib_list[GT_OWNER_VERTEX]->
            createIndirect(myVertexIndirect);

    if(consolidate_mesh)
    {
        const int nprim = myCounts.entries();

        if(!myInstanceTransforms)
        {
            mySelection = new GT_DAConstantValue<int>(nprim, 0, 1);
            myPickIDArray=new GT_DAConstantValue<int>(nprim, myHydraPrim.id(),1);
            auto &&ua = attrib_list[GT_OWNER_UNIFORM];
            if(ua)
            {
                ua = ua->addAttribute(GT_Names::lop_pick_id,myPickIDArray,true);
                ua = ua->addAttribute(GT_Names::selection, mySelection, true);
            }
            else
                ua = GT_AttributeList::createAttributeList(
                    GT_Names::lop_pick_id, myPickIDArray.get(),
                    GT_Names::selection,  mySelection.get());
        }
        else
        {
            const int ntrans = myInstanceTransforms->entries();
            auto sel = new GT_DANumeric<int>(ntrans, 1);
            memset(sel->data(), 0, sizeof(int)*ntrans);

            UT_ASSERT(ntrans == myHydraPrim.instanceIDs().entries());
            auto idn = new GT_DANumeric<int>(ntrans, 1);
            for(int i=0; i<ntrans; i++)
                idn->set(myHydraPrim.instanceIDs()(i), i);
            
            mySelection   = sel;
            myPickIDArray = idn;
        }
    }
        
    // build mesh
    GT_PrimPolygonMesh *mesh = nullptr;
    if(myIsSubD && myRefineLevel > 0)
    {
	auto smesh = new GT_PrimSubdivisionMesh(myCounts, myVertex,
						attrib_list[GT_OWNER_POINT],
						attrib_list[GT_OWNER_VERTEX],
						attrib_list[GT_OWNER_UNIFORM],
						attrib_list[GT_OWNER_DETAIL]);
	for (int i = 0; i < subd_tags.size(); ++i)
	    smesh->appendTag(subd_tags[i]);
	
	mesh = smesh;
    }
    else
    {
	mesh = new GT_PrimPolygonMesh(myCounts, myVertex,
				      attrib_list[GT_OWNER_POINT],
				      attrib_list[GT_OWNER_VERTEX],
				      attrib_list[GT_OWNER_UNIFORM],
				      attrib_list[GT_OWNER_DETAIL]);
    }

#if 0
    static UT_Lock theLock;
    theLock.lock();
    UTdebugPrint("Mesh count", myCounts.entries(),
                 "Vert count", myVertex->entries());
    mesh->dumpAttributeLists("XUSD_HydraGeoPrim", false);
    theLock.unlock();
#endif

    if(consolidate_mesh)
    {
        int inst_id = 0;
        if(!GetInstancerId().IsEmpty())
            inst_id = myHydraPrim.id();

        consolidateMesh(scene_delegate, mesh, id, dirty_bits, !has_n, inst_id);
    }
    else
    {
        if(myHydraPrim.isConsolidated())
        {
            myHydraPrim.scene().removeConsolidatedPrim(myHydraPrim.id());
            myDirtyMask = HUSD_HydraGeoPrim::ALL_DIRTY;
        }
        
        myHydraPrim.setConsolidated(false);
        
        GT_PrimitiveHandle mh = mesh;
        if(!generatePointNormals(scene_delegate, id, mh))
        {
            clearDirty(dirty_bits, HOLD_DIRTY_BITS);
            return;
        }

        if(myMaterialsNeedTangents && myGeometryNeedTangents)
            mh = generateTangents(mh);
        
        createInstance(scene_delegate, id, GetInstancerId(), dirty_bits,
                       mh.get(), &extents, lod, myMaterialID, 
                       (*dirty_bits & (HdChangeTracker::DirtyInstancer |
                                       HdChangeTracker::DirtyInstanceIndex )),
                       add_bbox);
    }
    clearDirty(dirty_bits);
}

void
XUSD_HydraGeoMesh::consolidateMesh(HdSceneDelegate    *scene_delegate,
                                   GT_PrimPolygonMesh *mesh,
                                   SdfPath const      &id,
                                   HdDirtyBits        *dirty_bits,
                                   bool                needs_normals,
                                   int                 instancer_id)
{
    HUSD_HydraPrim::RenderTag tag =
        HUSD_HydraPrim::renderTag(scene_delegate->GetRenderTag(id));

    myGTPrim = mesh;

    bool det_flip = false;
    bool has_transform = false;
    bool has_prim_transform = false;
    UT_Matrix4D transform;
    UT_Matrix4DArray itransforms;
    
    if(!myPrimTransform.isIdentity())
    {
        transform = myPrimTransform;
        has_prim_transform = true;
    }
    else
        transform.identity();
    
    if(myInstanceTransforms)
    {
        myInstanceTransforms->getTransforms(itransforms);
        if(has_transform)
        {
            for(int i=0; i<itransforms.entries(); i++)
                itransforms(i) = transform * itransforms(i);
        }
        has_transform = true;
    }

    GT_PrimitiveHandle ph;
    if(has_transform || has_prim_transform)
    {
        GT_AttributeListHandle vert, pnt;

        if(itransforms.entries() == 0)
        {
            GT_TransformHandle xform = new GT_Transform(&transform, 1);
            
            if(has_transform && transform.determinant() < 0.0)
                det_flip = true;
            
            if(mesh->getPointAttributes())
                pnt = mesh->getPointAttributes()->transform(xform);
            if(mesh->getVertexAttributes())
                vert = mesh->getVertexAttributes()->transform(xform);
            
            if(mesh->getPrimitiveType() == GT_PRIM_POLYGON_MESH)
            {
                mesh = new GT_PrimPolygonMesh(*mesh, pnt, vert,
                                              mesh->getUniformAttributes(),
                                              mesh->getDetailAttributes());
            }
            else // subd
            {
                auto smesh = (GT_PrimSubdivisionMesh*)mesh;
                mesh = new GT_PrimSubdivisionMesh(*smesh, pnt, vert,
                                                  mesh->getUniformAttributes(),
                                                  mesh->getDetailAttributes());
            }
            ph = mesh;
        }
        else
        {
            const int nprims = myCounts.entries();
            GT_CatPolygonMesh combiner;
            const int nt = itransforms.entries();
            for(int i=0; i<nt; i++)
            {
                UT_Matrix4D tr = itransforms(i);
                if(has_prim_transform)
                    tr = transform * tr;
                    
                GT_TransformHandle xform = new GT_Transform(&tr, 1);
                GT_PrimPolygonMesh *submesh = nullptr;
            
                if(has_transform && transform.determinant() < 0.0)
                    det_flip = true;
            
                if(mesh->getPointAttributes())
                    pnt = mesh->getPointAttributes()->transform(xform);
                if(mesh->getVertexAttributes())
                    vert = mesh->getVertexAttributes()->transform(xform);

                GT_DataArrayHandle sel= new GT_DAConstant(mySelection,i,nprims);
                GT_DataArrayHandle id= new GT_DAConstant(myPickIDArray,i,nprims);

                auto ua =  mesh->getUniformAttributes();
                if(ua)
                {
                    ua = ua->addAttribute(GT_Names::lop_pick_id, id, true);
                    ua = ua->addAttribute(GT_Names::selection, sel, true);
                }
                else
                    ua = GT_AttributeList::createAttributeList(
                                GT_Names::lop_pick_id, id,
                                GT_Names::selection, sel);
                
                if(mesh->getPrimitiveType() == GT_PRIM_POLYGON_MESH)
                {
                    submesh =
                        new GT_PrimPolygonMesh(*mesh, pnt, vert, ua,
                                               mesh->getDetailAttributes());
                }
                else // subd
                {
                    auto smesh = (GT_PrimSubdivisionMesh*)mesh;
                    submesh =
                        new GT_PrimSubdivisionMesh(*smesh, pnt, vert, ua,
                                                   mesh->getDetailAttributes());
                }
                combiner.append(submesh);
            }

            auto inst_da = new GT_DAConstantValue<int>(1,nt,1);
            GT_AttributeListHandle dh =
                GT_AttributeList::createAttributeList("__instances", inst_da);
            
            ph = combiner.result(dh);
        }
    }
    else
        ph = mesh;

    if(!generatePointNormals(scene_delegate, id, ph))
    {
        clearDirty(dirty_bits, HOLD_DIRTY_BITS);
        return;
    }

    if(myMaterialsNeedTangents && myGeometryNeedTangents)
        ph = generateTangents(ph);

    // Compute total bounding box, and per-instance bounding boxes (if any).
    GfRange3d extents = scene_delegate->GetExtent(id);
    UT_BoundingBoxF bbox(extents.GetMin()[0],
                         extents.GetMin()[1],
                         extents.GetMin()[2],
                         extents.GetMax()[0],
                         extents.GetMax()[1],
                         extents.GetMax()[2]);
    UT_Array<UT_BoundingBoxF> instance_bbox;

    if(!bbox.isValid())
    {
        bbox.makeInvalid();
        myGTPrim->enlargeBounds(&bbox, 1);
    }

    if(has_prim_transform)
        bbox.transform(UT_Matrix4F(transform));
        
    if(itransforms.entries())
    {
        // TODO: possibly thread (with UTparallelInvoke).
        UT_BoundingBoxF total_bbox;
        total_bbox.makeInvalid();
        for(auto &xf : itransforms)
        {
            UT_BoundingBoxF ibox = bbox;
            ibox.transform(xf);
            instance_bbox.append(ibox);
                
            total_bbox.enlargeBounds(ibox);
        }
        bbox = total_bbox;
    }
        
    myHydraPrim.setConsolidated(true);
    myInstance = nullptr;
        
    const bool left = det_flip ? (!myIsLeftHanded) : myIsLeftHanded;
    myHydraPrim.scene().consolidateMesh(ph, bbox,
                                        myHydraPrim.id(),
                                        myMaterialID, myDirtyMask,
                                        tag, left, needs_normals,
                                        instance_bbox, instancer_id);
}

bool
XUSD_HydraGeoMesh::generatePointNormals(HdSceneDelegate *scene_delegate,
                                        const PXR_NS::SdfPath &id,
                                        GT_PrimitiveHandle &handle)
{
    auto *mesh = UTverify_cast<GT_PrimPolygonMesh *>(handle.get());
    bool err = false;
    auto norm_mesh = mesh->createPointNormalsIfMissing(GA_Names::P, true, &err);
    if(norm_mesh)
    {
        handle = norm_mesh;
    }
    else if(err)
    {
        // If there was an error with the point normal computation,
        // it implies there are invalid indices in the mesh.
        myInstance.reset();
        myGTPrim.reset();
        removeFromDisplay(scene_delegate, id, GetInstancerId());
        return false;
    }

    return true;
}    


GT_PrimitiveHandle
XUSD_HydraGeoMesh::generateTangents(const GT_PrimitiveHandle &mh)
{
    GT_DataArrayHandle ph = mh->getPointAttributes()->get(GA_Names::P);
    GT_DataArrayHandle nh = mh->getPointAttributes()->get(GA_Names::N);
    GT_DataArrayHandle uvh=mh->getPointAttributes()->get(GT_Names::st);

    if(mh->getVertexAttributes())
    {
        if(!nh)
            nh = mh->getVertexAttributes()->get(GA_Names::N);
        if(!uvh)
            uvh = mh->getVertexAttributes()->get(GT_Names::st);
    }

    GT_PrimitiveHandle meshh;
    bool has_tangents = false;
    
    int64 tan_v = (ph->getDataId()
                   + (nh ? nh->getDataId() : 0)
                   +  (uvh ? uvh->getDataId() : 0));
    if(myTangentU && myTangentV &&
       myTangentDataID == tan_v)
    {
        meshh = mh;
        has_tangents = true;
    }
    else if(0) // Disable auto-mikkT in the delegate because it's so slow.
    {
        auto *mesh = UTverify_cast<GT_PrimPolygonMesh *>(mh.get());
        if(mesh->getMaxVertexCount() > 4)
            meshh = mesh->convex(3, false, false);
        else
            meshh = mh;

        has_tangents = GT_MikkT::computeTangentsBasic(meshh, GT_Names::st,
                                                      GA_Names::P, GA_Names::N,
                                                      0, &myTangentU,
                                                      &myTangentV, nullptr);
        myTangentDataID = tan_v;
    }

    if(has_tangents)
    {
        auto vertlist = meshh->getVertexAttributes();
        if(vertlist)
        {
            vertlist=vertlist->addAttribute(GT_Names::tangentu,myTangentU,true);
            vertlist=vertlist->addAttribute(GT_Names::tangentv,myTangentV,true);
        }
        else
        {
            vertlist = GT_AttributeList::createAttributeList(
                GT_Names::tangentu, myTangentU,
                GT_Names::tangentv, myTangentV);
        }

        GT_PrimitiveHandle rh;
        if(mh->getPrimitiveType() == GT_PRIM_POLYGON_MESH)
            rh= new GT_PrimPolygonMesh(
                *static_cast<GT_PrimPolygonMesh*>(meshh.get()),
                meshh->getPointAttributes(),
                vertlist,
                meshh->getUniformAttributes(),
                meshh->getDetailAttributes());
        else
            rh= new GT_PrimSubdivisionMesh(
                *static_cast<GT_PrimSubdivisionMesh*>(meshh.get()),
                meshh->getPointAttributes(),
                vertlist,
                meshh->getUniformAttributes(),
                meshh->getDetailAttributes());

        return rh;
    }
    else
    {
        //UTdebugPrint("Could not geneate tangents!");
        return mh;
    }
}
// -------------------------------------------------------------------------
    
XUSD_HydraGeoCurves::XUSD_HydraGeoCurves(TfToken const& type_id,
					 SdfPath const& prim_id,
					 GT_PrimitiveHandle &prim,
					 GT_PrimitiveHandle &instance,
					 int &dirty,
					 XUSD_HydraGeoPrim &hprim)
    : HdBasisCurves(prim_id),
      XUSD_HydraGeoBase(prim, instance, dirty, hprim),
      myBasis(GT_BASIS_LINEAR),
      myWrap(false)
{
}

XUSD_HydraGeoCurves::~XUSD_HydraGeoCurves()
{
    resetPrim();
}

void
XUSD_HydraGeoCurves::Sync(HdSceneDelegate *scene_delegate,
			  HdRenderParam *rparm,
			  HdDirtyBits *dirty_bits,
			  TfToken const &representation)
{
    SdfPath const      &id = GetId();
    
    if(isDeferred(id, scene_delegate, rparm, *dirty_bits))
    {
        if(myHydraPrim.index() == -1)
            myHydraPrim.scene().addDisplayGeometry(&myHydraPrim);
	return;
    }

    GT_Primitive       *gt_prim = myBasisCurve.get();
    int64		top_id = 1;

    // UTdebugPrint("Sync", id.GetText(), myHydraPrim.id(),
    //      		 GetInstancerId().GetText(),
    //       		 representation.GetText());
    // HdChangeTracker::DumpDirtyBits(*dirty_bits);

    UT_AutoLock prim_lock(myHydraPrim.lock());
    myDirtyMask = 0;
    
    // Visibility
    GEO_ViewportLOD lod = checkVisibility(scene_delegate, id, dirty_bits);
    if(lod == GEO_VIEWPORT_HIDDEN)
    {
	removeFromDisplay(scene_delegate, id, GetInstancerId());
	return;
    }
    
    if(*dirty_bits & HdChangeTracker::DirtyMaterialId)
    {
        for(auto matref : myHydraPrim.materialReferences())
        {
            auto entry = myHydraPrim.scene().materials().find(matref);
            if(entry != myHydraPrim.scene().materials().end())
                entry->second->removePrimRef(myHydraPrim.id());
        }
        
        myHydraPrim.clearMaterials();
        
        int prev_mat = myMaterialID;
        myMaterialID = -1;
	SdfPath mat_id = scene_delegate->GetMaterialId(GetId());
        if(!mat_id.IsEmpty())
        {
            HUSD_Path path(mat_id);
            auto entry = myHydraPrim.scene().materials().find(path);
            if(entry != myHydraPrim.scene().materials().end())
            {
                auto &hmat = entry->second;
                if(hmat->isValid())
                {
                    myMaterialID = hmat->getMaterialID();
                    hmat->addPrimRef(myHydraPrim.id());
                    myHydraPrim.addMaterialRef(hmat->path());
                }
            }
        }
        if(myMaterialID != prev_mat)
            myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::MAT_CHANGE;
    }
    
    // Transforms
    if (!gt_prim || HdChangeTracker::IsTransformDirty(*dirty_bits, id))
    {
	myPrimTransform =
            GusdUT_Gf::Cast(GfMatrix4d(scene_delegate->GetTransform(id)));
	myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::INSTANCE_CHANGE;
    }

    // Make sure our instancer and it's parent instancers are synced.
    _UpdateInstancer(scene_delegate, dirty_bits);
    HdInstancer::_SyncInstancerAndParents(
        scene_delegate->GetRenderIndex(), GetInstancerId());

    GT_TransformHandle th;
    buildTransforms(scene_delegate, rparm, id, GetInstancerId(), dirty_bits,
                    myHydraPrim.id());
    if(myInstanceTransforms && myInstanceTransforms->entries() == 0)
    {
	// zero instance transforms means nothing should be displayed.
	removeFromDisplay(scene_delegate, id, GetInstancerId());
	return;
    }

    // Topology
    if(gt_prim && gt_prim->getDetailAttributes())
    {
	auto top = gt_prim->getDetailAttributes()->get(GT_Names::topology);
	if(top)
	    top_id = top->getI64(0);
    }
    
    if (!myCounts || !gt_prim || 
	HdChangeTracker::IsTopologyDirty(*dirty_bits, id))
    {
        HdBasisCurvesTopology top;
        // Even though the topology format is the same for metaCurves and
        // standard USD basis curves, for metacurves we need to query the
        // topology in a slightly roundabout way because the normal
        // GetBasisCurvesTopology screens out any non-basisCurves Hd
        // primitive types.
        if (myHydraPrim.primType() == HusdHdPrimTypeTokens->metaCurves)
        {
            VtValue topvalue = scene_delegate->Get(id, TfToken("topology"));
            if (topvalue.IsHolding<HdBasisCurvesTopology>())
                top = topvalue.UncheckedGet<HdBasisCurvesTopology>();
        }
        else
            top = GetBasisCurvesTopology(scene_delegate);
	top_id ++;

	TfToken ctype = top.GetCurveType();
	if(ctype == HdTokens->cubic)
	{
	    TfToken basis = top.GetCurveBasis();
	    if(basis == HdTokens->bezier)
		myBasis = GT_BASIS_BEZIER;
	    else if(basis == HdTokens->bSpline)
		myBasis = GT_BASIS_BSPLINE;
	    else if(basis == HdTokens->catmullRom)
		myBasis = GT_BASIS_CATMULLROM;
	}
	else
	    myBasis = GT_BASIS_LINEAR;
        
	myWrap = (top.GetCurveWrap() == HdTokens->periodic);

	if(top.GetCurveWrap() != HdTokens->segmented)
	    myCounts=XUSD_HydraUtils::createGTArray(top.GetCurveVertexCounts());
	else
	{
	    int num = top.CalculateNeededNumberOfControlPoints();
	    myCounts = new GT_DAConstantValue<int32>(num, 2, 1);
	}

	if(top.HasIndices())
	    myIndices = XUSD_HydraUtils::createGTArray(top.GetCurveIndices());
	else
	    myIndices.reset();
	
	myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::TOP_CHANGE;
    }

    // available attributes
    if(!gt_prim || myAttribMap.size() == 0 ||
       (*dirty_bits & HdChangeTracker::DirtyPrimvar) ||
       	HdChangeTracker::IsTopologyDirty(*dirty_bits, id))
    {
        bool cubic = (myBasis != GT_BASIS_LINEAR);
	UT_Map<GT_Owner, GT_Owner> remap;
	remap[GT_OWNER_POINT] = GT_OWNER_VERTEX;
	XUSD_HydraUtils::buildAttribMap(scene_delegate, id, myAttribMap,
                                        cubic ? GT_OWNER_UNIFORM:GT_OWNER_POINT,
					&remap);
    }

    GT_AttributeListHandle attrib_list[GT_OWNER_MAX];
    
    auto top = new GT_DAConstantValue<int64>(1, top_id, 1);
    attrib_list[GT_OWNER_DETAIL] =
	GT_AttributeList::createAttributeList(GT_Names::topology,top);
    
    bool pnt_exists = false;
    updateAttrib(HdTokens->points, "P"_sh, scene_delegate, id, dirty_bits,
		 gt_prim, attrib_list, GT_TYPE_POINT,nullptr,false,&pnt_exists);
    if(!pnt_exists)
    {
	myInstance.reset();
	myGTPrim.reset();
	clearDirty(dirty_bits, HOLD_DIRTY_BITS);
	return;
    }

    updateAttrib(HdTokens->displayColor, "Cd"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                 GT_TYPE_COLOR);
    updateAttrib(HdTokens->displayOpacity, "Alpha"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                 GT_TYPE_NONE);
    
    int curve_style = 1;
    auto gl_wire = myAttribMap.find(HusdHdPrimvarTokens->glWire.GetText());
    if(gl_wire != myAttribMap.end())
    {
        int wire =
            XUSDgetIntValue(scene_delegate->Get(id,HusdHdPrimvarTokens->glWire),
                            0);
        if(wire)
            curve_style = 0;
    }
    auto curve_style_primvar =
        myAttribMap.find(HusdHdPrimvarTokens->glCurveStyle.GetText());
    if(curve_style_primvar != myAttribMap.end())
    {
        curve_style = XUSDgetIntValue(scene_delegate->Get(id,HusdHdPrimvarTokens->glCurveStyle), 1);
    }
    
    if(curve_style != 0)    
    {
        updateAttrib(HusdHdPrimvarTokens->widths, "width"_sh,
                     scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                     GT_TYPE_NONE);
        if(curve_style == 2)
        {
            GT_DataArrayHandle dh = new GT_DAConstantValue<int32>(1, 1, 1);
            attrib_list[GT_OWNER_DETAIL] = attrib_list[GT_OWNER_DETAIL]->
                addAttribute("rounded_curves"_sh, dh, true);
        }
    }
    else if(gt_prim)
    {
        GT_Owner owner;
        if(gt_prim->findAttribute("width"_sh, owner, 0))
        {
            if(owner == GT_OWNER_DETAIL)
                gt_prim->getDetailAttributes()->removeAttribute("width"_sh);
            else if(owner == GT_OWNER_POINT)
                gt_prim->getPointAttributes()->removeAttribute("width"_sh);
            else if(owner == GT_OWNER_VERTEX)
                gt_prim->getVertexAttributes()->removeAttribute("width"_sh);
            else if(owner == GT_OWNER_UNIFORM)
                gt_prim->getUniformAttributes()->removeAttribute("width"_sh);
        }
        if(gt_prim->findAttribute("rounded_curves"_sh, owner, 0))
            gt_prim->getDetailAttributes()->removeAttribute("rounded_curves"_sh);
    }
        
        
    updateAttrib(HdTokens->normals, "N"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
		 GT_TYPE_NORMAL);

    GT_PrimitiveHandle ph;
    GT_AttributeListHandle verts;
    if(myIndices)
	verts = attrib_list[GT_OWNER_VERTEX]->createIndirect(myIndices);
    else
	verts = attrib_list[GT_OWNER_VERTEX];
	    
    auto cmesh = new GT_PrimCurveMesh(myBasis, myCounts, verts,
				      attrib_list[GT_OWNER_UNIFORM],
				      attrib_list[GT_OWNER_DETAIL],
				      myWrap);
    myBasisCurve = cmesh;
    if(myBasis != GT_BASIS_LINEAR)
    {
 	ph = cmesh->refineToLinear();
	if(!ph)
	    ph = cmesh;
	UT_ASSERT(ph);
    }
    else
	ph = cmesh;

    createInstance(scene_delegate, id, GetInstancerId(), dirty_bits,
                   ph.get(), nullptr, lod, myMaterialID,
		   (*dirty_bits & (HdChangeTracker::DirtyInstancer |
				   HdChangeTracker::DirtyInstanceIndex)));

    // cmesh->dumpAttributeLists("XUSD_HydraGeoCurves", false);
    // if(attrib_list[GT_OWNER_VERTEX])
    // 	attrib_list[GT_OWNER_VERTEX]->dumpList("verts", false);
    
    clearDirty(dirty_bits);
}
    
void
XUSD_HydraGeoCurves::Finalize(HdRenderParam *rparms)
{
    HdRprim::Finalize(rparms);
}

HdDirtyBits
XUSD_HydraGeoCurves::GetInitialDirtyBitsMask() const
{
    return HdChangeTracker::AllDirty;
}

HdDirtyBits
XUSD_HydraGeoCurves::_PropagateDirtyBits(HdDirtyBits bits) const
{
    return bits;
}

void
XUSD_HydraGeoCurves::_InitRepr(TfToken const &representation,
			       HdDirtyBits *dirty_bits)
{

}


// -------------------------------------------------------------------------

XUSD_HydraGeoVolume::XUSD_HydraGeoVolume(TfToken const& type_id,
					 SdfPath const& prim_id,
					 GT_PrimitiveHandle &gt_prim,
					 GT_PrimitiveHandle &instance,
					 int &dirty,
					 XUSD_HydraGeoPrim &hprim)
    : HdVolume(prim_id),
      XUSD_HydraGeoBase(gt_prim, instance, dirty, hprim)
{
    hprim.needsGLStateCheck(true);
}

XUSD_HydraGeoVolume::~XUSD_HydraGeoVolume()
{
    resetPrim();
}
  
void
XUSD_HydraGeoVolume::Finalize(HdRenderParam *rparm)
{
    // Here we clear out any resources.
    myHydraPrim.scene().removeVolumeUsingFields(GetId());

    HdRprim::Finalize(rparm);
}


HdDirtyBits
XUSD_HydraGeoVolume::GetInitialDirtyBitsMask() const
{
    return HdChangeTracker::AllDirty;
}

HdDirtyBits
XUSD_HydraGeoVolume::_PropagateDirtyBits(HdDirtyBits bits) const
{
    return bits;
}

void
XUSD_HydraGeoVolume::_InitRepr(TfToken const &representation,
			       HdDirtyBits *dirty_bits)
{
}

void
XUSD_HydraGeoVolume::Sync(HdSceneDelegate *scene_delegate,
			  HdRenderParam *rparm,
			  HdDirtyBits *dirty_bits,
			  TfToken const &representation)
{
    SdfPath const &id = GetId();
  
    if(isDeferred(id, scene_delegate, rparm, *dirty_bits))
    {
        if(myHydraPrim.index() == -1)
            myHydraPrim.scene().addDisplayGeometry(&myHydraPrim);
	return;
    }

    GU_ConstDetailHandle	 gdh;
    GT_PrimitiveHandle		 gtvolume;
    
    UT_AutoLock prim_lock(myHydraPrim.lock());
    
    // Visibility
    GEO_ViewportLOD lod = checkVisibility(scene_delegate, id, dirty_bits);
    if(lod == GEO_VIEWPORT_HIDDEN)
    {
	removeFromDisplay(scene_delegate, id, GetInstancerId());
	return;
    }

    // available attributes
    if(myAttribMap.size() == 0 ||
       (*dirty_bits & HdChangeTracker::DirtyPrimvar) ||
       	HdChangeTracker::IsTopologyDirty(*dirty_bits, id))
    {
	UT_Map<GT_Owner, GT_Owner> remap;
	remap[GT_OWNER_POINT] = GT_OWNER_VERTEX;
	XUSD_HydraUtils::buildAttribMap(scene_delegate, id, myAttribMap,
                                        GT_OWNER_POINT, &remap);
    }
    
    // Transforms
    if (!gtvolume || HdChangeTracker::IsTransformDirty(*dirty_bits, id))
    {
	myPrimTransform =
            GusdUT_Gf::Cast(GfMatrix4d(scene_delegate->GetTransform(id)));
	myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::INSTANCE_CHANGE;
    }

    // Make sure our instancer and it's parent instancers are synced.
    _UpdateInstancer(scene_delegate, dirty_bits);
    HdInstancer::_SyncInstancerAndParents(
        scene_delegate->GetRenderIndex(), GetInstancerId());

    GT_TransformHandle th;
    buildTransforms(scene_delegate, rparm, id, GetInstancerId(), dirty_bits,
                    myHydraPrim.id());
    if(myInstanceTransforms && myInstanceTransforms->entries() == 0)
    {
	// zero instance transforms means nothing should be displayed.
	removeFromDisplay(scene_delegate, id, GetInstancerId());
	return;
    }

    // Favour density, but if not found, use the first field.
    HdVolumeFieldDescriptor desc;
    auto fields = scene_delegate->GetVolumeFieldDescriptors(id);
    bool first = true;
    for (auto &&itr : fields)
    {
        UT_StringHolder field_name( itr.fieldId.GetString() );
        if(field_name.endsWith("density"))
        {
            desc = itr;
            break;
        }
        if(first)
        {
            desc = itr;
            first = false;
        }
    }
    
    // 3D texture for the volume.
    if(fields.size() > 0)
    {
	HdBprim const *bprim = scene_delegate->GetRenderIndex().GetBprim(
	    desc.fieldPrimType, desc.fieldId);

	if (bprim)
	{
	    auto field = static_cast<const XUSD_HydraField *>(bprim);
	    gtvolume = field->getGTPrimitive();
	    myHydraPrim.scene().addVolumeUsingField(id, desc.fieldId);
	    myDirtyMask |= HUSD_HydraGeoPrim::TOP_CHANGE;
	}
    }

    // If there were no field prims for this volumes, just exit.
    if (!gtvolume)
    {
	removeFromDisplay(scene_delegate, id, GetInstancerId());
	return;
    }

    if(*dirty_bits & HdChangeTracker::DirtyTopology)
	myDirtyMask |= HUSD_HydraGeoPrim::TOP_CHANGE;

    clearDirty(dirty_bits);

    
    // create the container packed prim.
    createInstance(scene_delegate, id, GetInstancerId(), dirty_bits,
		   gtvolume.get(), nullptr, lod, -1,
		   (*dirty_bits & (HdChangeTracker::DirtyInstancer |
				   HdChangeTracker::DirtyInstanceIndex)));
}

// --------------------------------------------------------------------------

XUSD_HydraGeoPoints::XUSD_HydraGeoPoints(TfToken const& type_id,
					 SdfPath const& prim_id,
					 GT_PrimitiveHandle &gt_prim,
					 GT_PrimitiveHandle &instance,
					 int &dirty,
					 XUSD_HydraGeoPrim &hprim)
    : HdPoints(prim_id),
      XUSD_HydraGeoBase(gt_prim, instance, dirty, hprim)
{
}

XUSD_HydraGeoPoints::~XUSD_HydraGeoPoints()
{
    resetPrim();
}

void
XUSD_HydraGeoPoints::Sync(HdSceneDelegate *scene_delegate,
			  HdRenderParam *rparm,
			  HdDirtyBits *dirty_bits,
			  TfToken const &representation)
{
    SdfPath const &id = GetId();
    
    if(isDeferred(id, scene_delegate, rparm, *dirty_bits))
    {
        if(myHydraPrim.index() == -1)
            myHydraPrim.scene().addDisplayGeometry(&myHydraPrim);
	return;
    }
    
    GT_Primitive       *gt_prim = myGTPrim.get();
    GT_AttributeListHandle attrib_list[GT_OWNER_MAX];

    UT_AutoLock prim_lock(myHydraPrim.lock());
    
    // Visibility
    GEO_ViewportLOD lod = checkVisibility(scene_delegate, id, dirty_bits);
    if(lod == GEO_VIEWPORT_HIDDEN)
    {
	removeFromDisplay(scene_delegate, id, GetInstancerId());
	return;
    }

    // available attributes
    if(!gt_prim || myAttribMap.size() == 0 ||
       (*dirty_bits & HdChangeTracker::DirtyPrimvar) ||
       	HdChangeTracker::IsTopologyDirty(*dirty_bits, id))
    {
	XUSD_HydraUtils::buildAttribMap(scene_delegate, id, myAttribMap);
    }
    
    // Transforms
    if (!gt_prim || HdChangeTracker::IsTransformDirty(*dirty_bits, id))
    {
	myPrimTransform =
            GusdUT_Gf::Cast(GfMatrix4d(scene_delegate->GetTransform(id)));
	myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::INSTANCE_CHANGE;
    }

    // Make sure our instancer and it's parent instancers are synced.
    _UpdateInstancer(scene_delegate, dirty_bits);
    HdInstancer::_SyncInstancerAndParents(
        scene_delegate->GetRenderIndex(), GetInstancerId());

    GT_TransformHandle th;
    buildTransforms(scene_delegate, rparm, id, GetInstancerId(), dirty_bits,
                    myHydraPrim.id());
    if(myInstanceTransforms && myInstanceTransforms->entries() == 0)
    {
	// zero instance transforms means nothing should be displayed.
	removeFromDisplay(scene_delegate, id, GetInstancerId());
	return;
    }

    updateAttrib(HdTokens->points, "P"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                 GT_TYPE_POINT);
    updateAttrib(HdTokens->displayColor, "Cd"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                 GT_TYPE_COLOR);
    updateAttrib(HdTokens->normals, "N"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                 GT_TYPE_NORMAL);
    updateAttrib(TfToken("gl_spritetex"), "gl_spritetex"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                 GT_TYPE_NONE);
    updateAttrib(TfToken("widths"), "pscale"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                 GT_TYPE_NONE);
    updateAttrib(TfToken("spritescale"), "spritescale"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                 GT_TYPE_NONE);

    auto points = new GT_PrimPointMesh(attrib_list[GT_OWNER_POINT],
				       attrib_list[GT_OWNER_DETAIL]);

    createInstance(scene_delegate, id, GetInstancerId(), dirty_bits,
                   points, nullptr, lod, -1,
 		   (*dirty_bits & (HdChangeTracker::DirtyInstancer |
				   HdChangeTracker::DirtyInstanceIndex)));
    
    clearDirty(dirty_bits);   
}
    
void
XUSD_HydraGeoPoints::Finalize(HdRenderParam *rparm)
{
    HdRprim::Finalize(rparm);
}

HdDirtyBits
XUSD_HydraGeoPoints::GetInitialDirtyBitsMask() const
{
    return HdChangeTracker::AllDirty;
}


HdDirtyBits
XUSD_HydraGeoPoints::_PropagateDirtyBits(HdDirtyBits bits) const
{
    return bits;
}

void
XUSD_HydraGeoPoints::_InitRepr(TfToken const &representation,
			       HdDirtyBits *dirty_bits)
{
}


// -------------------------------------------------------------------------

XUSD_HydraGeoBounds::XUSD_HydraGeoBounds(TfToken const& type_id,
					 SdfPath const& prim_id,
					 GT_PrimitiveHandle &prim,
					 GT_PrimitiveHandle &instance,
					 int &dirty,
					 XUSD_HydraGeoPrim &hprim)
    : HdBasisCurves(prim_id),
      XUSD_HydraGeoBase(prim, instance, dirty, hprim),
      myExtentID(-1)
{
}

XUSD_HydraGeoBounds::~XUSD_HydraGeoBounds()
{
    resetPrim();
}

void
XUSD_HydraGeoBounds::Sync(HdSceneDelegate *scene_delegate,
			  HdRenderParam *rparm,
			  HdDirtyBits *dirty_bits,
			  TfToken const &representation)
{
    SdfPath const      &id = GetId();
    
    if(isDeferred(id, scene_delegate, rparm, *dirty_bits))
    {
        if(myHydraPrim.index() == -1)
            myHydraPrim.scene().addDisplayGeometry(&myHydraPrim);
	return;
    }

    GT_Primitive       *gt_prim = myBasisCurve.get();
    
    // UTdebugPrint("Sync", id.GetText(), myHydraPrim.id(),
    //      		 GetInstancerId().GetText(),
    //      		 representation.GetText());
    // HdChangeTracker::DumpDirtyBits(*dirty_bits);

    UT_AutoLock prim_lock(myHydraPrim.lock());
    myDirtyMask = 0;
    
    // Visibility
    GEO_ViewportLOD lod = checkVisibility(scene_delegate, id, dirty_bits);
    if(lod == GEO_VIEWPORT_HIDDEN)
    {
	removeFromDisplay(scene_delegate, id, GetInstancerId());
	return;
    }

    // available attributes
    if(!gt_prim || myAttribMap.size() == 0 ||
       (*dirty_bits & HdChangeTracker::DirtyPrimvar))
    {
	UT_Map<GT_Owner, GT_Owner> remap;
	remap[GT_OWNER_POINT] = GT_OWNER_VERTEX;
	XUSD_HydraUtils::buildAttribMap(scene_delegate, id, myAttribMap,
					GT_OWNER_VERTEX, &remap);
    }

    // Transforms
    if (!gt_prim || HdChangeTracker::IsTransformDirty(*dirty_bits, id))
    {
	myPrimTransform =
            GusdUT_Gf::Cast(GfMatrix4d(scene_delegate->GetTransform(id)));
	myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::INSTANCE_CHANGE;
    }

    // Make sure our instancer and it's parent instancers are synced.
    _UpdateInstancer(scene_delegate, dirty_bits);
    HdInstancer::_SyncInstancerAndParents(
        scene_delegate->GetRenderIndex(), GetInstancerId());

    GT_TransformHandle th;
    buildTransforms(scene_delegate, rparm, id, GetInstancerId(), dirty_bits,
                    myHydraPrim.id());
    if(myInstanceTransforms && myInstanceTransforms->entries() == 0)
    {
	// zero instance transforms means nothing should be displayed.
	removeFromDisplay(scene_delegate, id, GetInstancerId());
	return;
    }

    // Topology never changes for a bounding box. Just get the bboxmin and max
    // and build a curve mesh from that.
    GT_AttributeListHandle attrib_list[GT_OWNER_MAX];
    
    updateAttrib(HdTokens->displayColor, "Cd"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                 GT_TYPE_COLOR);
    updateAttrib(HdTokens->displayOpacity, "Alpha"_sh,
		 scene_delegate, id, dirty_bits, gt_prim, attrib_list,
                 GT_TYPE_NONE);

    GfRange3d extents = scene_delegate->GetExtent(id);

    if (!extents.IsEmpty())
    {
        static const int theIndices[] = {
            /* bottom face */ 0, 4, 4, 6, 6, 2, 2, 0,
            /* top face */    1, 5, 5, 7, 7, 3, 3, 1,
            /* edge pairs */  0, 1, 4, 5, 6, 7, 2, 3
        };
        static GT_DataArrayHandle theIndicesArray =
            new GT_Int32Array(theIndices, 24, 1);
        static GT_DataArrayHandle theVertexCounts =
            new GT_DAConstantValue<int32>(12, 2, 1);

        fpreal32 points[24] = {
            fpreal32(extents.GetMin()[0]),
            fpreal32(extents.GetMin()[1]),
            fpreal32(extents.GetMin()[2]),
            fpreal32(extents.GetMin()[0]),
            fpreal32(extents.GetMin()[1]),
            fpreal32(extents.GetMax()[2]),
            fpreal32(extents.GetMin()[0]),
            fpreal32(extents.GetMax()[1]),
            fpreal32(extents.GetMin()[2]),
            fpreal32(extents.GetMin()[0]),
            fpreal32(extents.GetMax()[1]),
            fpreal32(extents.GetMax()[2]),
            fpreal32(extents.GetMax()[0]),
            fpreal32(extents.GetMin()[1]),
            fpreal32(extents.GetMin()[2]),
            fpreal32(extents.GetMax()[0]),
            fpreal32(extents.GetMin()[1]),
            fpreal32(extents.GetMax()[2]),
            fpreal32(extents.GetMax()[0]),
            fpreal32(extents.GetMax()[1]),
            fpreal32(extents.GetMin()[2]),
            fpreal32(extents.GetMax()[0]),
            fpreal32(extents.GetMax()[1]),
            fpreal32(extents.GetMax()[2])
        };
        GT_DataArrayHandle points_array =
            new GT_Real32Array(points, 8, 3);
        
        GT_DataArrayHandle vertices_array =
            new GT_DAIndirect(theIndicesArray, points_array);
        vertices_array->setDataId(myExtentID++);

        UT_ASSERT(!attrib_list[GT_OWNER_VERTEX]);
        attrib_list[GT_OWNER_VERTEX] = GT_AttributeList::
            createAttributeList("P"_sh, vertices_array);

        GT_PrimitiveHandle cmesh =
            new GT_PrimCurveMesh(GT_BASIS_LINEAR,
                theVertexCounts,
                attrib_list[GT_OWNER_VERTEX],
                attrib_list[GT_OWNER_UNIFORM],
                attrib_list[GT_OWNER_DETAIL],
                false);
        myBasisCurve = cmesh;
        createInstance(scene_delegate, id, GetInstancerId(),
                       dirty_bits, cmesh.get(), &extents, lod, -1,
                       (*dirty_bits & (HdChangeTracker::DirtyInstancer |
                       HdChangeTracker::DirtyInstanceIndex)));

        myDirtyMask = myDirtyMask | HUSD_HydraGeoPrim::GEO_CHANGE;
        // cmesh->dumpAttributeLists("XUSD_HydraGeoBounds", false);
        // if(attrib_list[GT_OWNER_VERTEX])
        // 	attrib_list[GT_OWNER_VERTEX]->dumpList("verts", false);
    }
    else
        myBasisCurve.reset();

    clearDirty(dirty_bits);
}
    
void
XUSD_HydraGeoBounds::Finalize(HdRenderParam *rparms)
{
    HdRprim::Finalize(rparms);
}

HdDirtyBits
XUSD_HydraGeoBounds::GetInitialDirtyBitsMask() const
{
    return HdChangeTracker::AllDirty;
}

HdDirtyBits
XUSD_HydraGeoBounds::_PropagateDirtyBits(HdDirtyBits bits) const
{
    return bits;
}

void
XUSD_HydraGeoBounds::_InitRepr(TfToken const &representation,
			       HdDirtyBits *dirty_bits)
{
}


PXR_NAMESPACE_CLOSE_SCOPE
